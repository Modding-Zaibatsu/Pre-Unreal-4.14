INTSourceChangelist:2621752
Availability:Docs
Title:アクタのティック
Crumbs:%ROOT%, Programming
Description:各フレーム毎にアクタを更新するために使用するティック システムの説明
Version:4.9

[TOC (start:2 end:3)]

アクタは、1 フレームにつき 1 回ずつ、フレームの間の経過時間でティックされます。ティックの順序は、アクタがワールド中のアクタ リスト (全レベルのアクタ リストをまとめたもの) に出現する順序になります。アクタのティックは、 
非同期動作の前、非同期動作の間、そして、非同期動作の後の 3 つの局面で行われます。アクタがどのグループでティックされるかは TickGroup メンバによって制御されます。非同期動作 (物理的動作など) の前に状態を更新する必要があるアクタは、 
TG_PreAsyncWork グループに割り当てる必要があります。そうしないと、誤動作や、1 フレームのずれなどの問題を引き起こします。物理やその他のスレッドと並列にティックしてよいアクタは、 
TG_DuringAsyncWork グループに割り当てます。このグループ内のアクタが、剛体物理データを操作するような関数を呼び出すと、その呼び出しは無視され、 
エラーが記録されます。このような呼び出しは、メモリ リークや無効なシーン状態などを招く危険があるので、必ず修正するようにしてください。SpawnActor(), MoveActor(), SetLocation(),SetCollision() 等にも
 同じことが該当します。こうした関数は、実行を継続されますが、物理スレッドには影響を及ぼしません。また、エラーも記録されます。最後に、物理状態の更新に依存するアクタは、 
 グループを TG_PostAsyncWork に設定します。このグループのアクタ (ビークル、ラグドールなど) の正確なワールド状態は、物理シミュレーションの結果によって決まります。この段階なら、 
 物理動作の関数や、移動、スポーン、衝突などの Unreal 関数を呼び出しても安全です。


以下は、アクタを各ティック グループに入れる場合のメリットとデメリットのリストです。



### TG_PreAsyncGroup

+ 任意の Unreal 関数または Novodex 物理関数を安全に呼び出すことができます。

+ 物理シミュレーション用の位置や回転などを更新します。

- 直前のフレームの物理シミュレーション結果で動作します。

- 並列処理は行われません。



### TG_DuringAsyncGroup

+ 物理シミュレーションと並列に動作します。

- シーン データに書き込み (読み込みは OK) を行うような特定の Unreal 関数、および、任意の Novodex 物理関数を呼び出すのは危険です。



### TG_PostAsyncGroup

+ 任意の Unreal 関数または Novodex 物理関数を安全に呼び出すことができます。

- 現在のフレームの物理シミュレーション データで動作します。

- 並列処理は行われません。

従って、アクタを任意のリストに入れる一般規則は以下のようになります。

1. 衝突状態を変更したり、衝突可能なアクタをスポーンしたり、Novodex データに書き込みを行ったりするアクタは、TG_PreAsyncWork に入れる必要があります。通常ここに入れられるアクタとしては、Pawn、武器、および、剛体クラスの一部があります。
1. 衝突状態を変更したり、衝突するアクタをスポーンしたり (衝突しないアクタならよい)、Novodex データを変更するアクタは、TG_DuringAsyncWork グループに配置する必要があります。ここでは、アクタのティックにかかる時間が物理シミュレーションにかかる時間を隠してくれる、つまり、ここで 2ms ティックすると、2ms のシミュレーション時間が自由になるので、最適の場所です。このグループに入れるアクタの候補としては、パーティクル システム、オーディオ、AI 処理などがあります。
1. アクタ自体の Unreal データを更新する前に、Novodex からデータを取得する必要があるアクタは、TG_PostAsyncWork に入れる必要があります。ビークルやラグドールは、たいていこのグループに入れられます。



##アクタのスポーン

スポーンされたアクタ (および、そのコンポーネントすべて) は、設定されたティック グループに関わらず、スポーンされたグループの中でティックされます。新たにスポーンされたアクタが、正しいティック グループでティックされるのは、 
次のフレームからです。ただし、非同期動作の間にスポーンされたアクタのティックは例外で、TG_PostAsyncWork まで延期されます。



## コンポーネントのティック

アクタと同様、コンポーネントも別々のティック グループに配置することができます。これまでは、アクタのコンポーネントはすべて、アクタのティックの際にティックされていました。これは現在でも同様ですが、 
アクタと異なるグループに入れる必要のあるコンポーネントは、ティックされる際の管理を行うリストに追加されます。コンポーネントのティック グループへの割り当ては、アクタの割り当てと同じ基準で行う必要があります。



## ティック コードのフロー

| **ゲーム スレッド** | **物理スレッド** |
| --- | --- |
| ワールドのアクタ リストをチェックして、TG_PreAsyncWork の中のアクタをティックし、それ以外のアクタは遅延する | アイドル |
| ティックされた各アクタのコンポーネント リストをチェックして、TG_PreAsyncWork の中のコンポーネントをティックし、それ以外のアクタは遅延する | アイドル |
| 物理スレッドを開始するように通知する | シミュレーションを開始する |
| TG_DuringAsyncWork リストの各アクタをティックする | 物理系をシミュレートする|
| アクタの各コンポーネントをティックする (必要があれば遅延する) | 物理系をシミュレートする |
| TG_DuringAsycnWork がコンポーネントをティックするまで、各コンポーネントを遅延する | 物理系をシミュレートする |
|物理動作が完了するまでブロック | 物理系をシミュレートする |
| TG_PostAsyncWork リストの各アクタをティックする | アイドル |
| アクタの各コンポーネントをティックする | アイドル |
| TG_PostAsycnWork がコンポーネントをティックするまで、各コンポーネントを遅延する | アイドル |
|レンダリングおよび繰り返し | アイドル |



## 詳細なコードのフロー (およびティック後)


### コードのフロー (フレーム毎)


    
    Object ticking
       Pre-physics
          controller (input)
          pawn (script)
          Components
             SkeletalMeshComponent: update animations, skeleton controls, then compute the matrices
       Physics, async
          pawn physics
       Post-physics
       Camera tick
       Viewport tick
    
       "server travelling"
       "client travelling"
       streaming
    
    Render
       Calculate VP matrix (ask camera in script, returns cached value)
       Controller.PreRender
          UTPawn.PreRender (pretty good thing for licencees to use as well)
       Render everything
    
    Audio
    
    Callgraph computation
    




### なぜティックは重要なのか ?

ティックやレンダリング順序について理解することは、1 フレームのずれの発生を防ぎ、呼び出し順への依存関係を回避するために不可欠です。たとえばカメラは、すべてのティックが済んでから更新されるので、
 カメラに関係のある処理 (プレーヤーの所持品やレーザー点など) は、すべて、PreRender に行われる必要があります。しかし、_アニメーション_ がカメラ位置に依存している場合は、 
 1 フレームのずれが **発生します** 。なぜなら、アニメーションは物理系の前処理の間に発生し、ポーン動作は物理動作の間に発生し、カメラは通常ポーンの位置に依存するので、 
 アニメーションの依存関係がループになるからです。この問題を回避するためには、このうちのどれかを 1 フレーム中に複数回、計算しなくてはならないかもしれません。たとえば、アニメーション ティックとカメラ ティックを物理動作の後に移動すれば、 
 アニメーションは正しくカメラ位置を更新できるはずです (ただし、特にコーディングしない限り、カメラは 1 フレームにつき 2 回更新されます)。

 - Jordan Weitz 著

 




