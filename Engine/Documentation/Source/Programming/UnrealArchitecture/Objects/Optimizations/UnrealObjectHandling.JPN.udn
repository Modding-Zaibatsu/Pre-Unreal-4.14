INTSourceChangelist:2728788
Availability:Public
Title:アンリアルのオブジェクトのハンドリング
Crumbs:%ROOT%
Description:UObject システムの機能の概要
Version:4.9

[TOC (start:2 end:2)]

クラス、プロパティ、関数を適切なマクロでマーク付けすると、それぞれ UClasses、UProperties、UFunctions になります。その結果、アンリアル エンジンがこれらにアクセスできるようになり、 
数多くの内部のハンドリング機能が実装できます。

##ガーベジ コレクション

アンリアル エンジンでは、ガーベジ コレクション スキームを実装しています。この場合、参照されなくなった、または破棄と明示的にフラグ付けされた UObjects は定期的にクリーンアップされます。アンリアル エンジンでは、 
どのオブジェクトがまだ使用中であるか、どのオブジェクトがオーファンになっているかを判断するための参照グラフをビルドします。このグラフの元は、"root set" と指定されている一連のオブジェクトです。このルートセットには、 
どのオブジェクトでも追加できます。ガーベジ コレクションが行われると、アンリアル エンジンではすべての参照されているオブジェクトを追跡することができます。これは、"root set" から始まり、既知の UObject 参照のツリーを検索することで行います。参照されていないオブジェクトは、 
不要になったとみなされ、取り除かれます。 

ここでの実用的な実装としては、通常、ガーベジ コレクションの対象から外したいオブジェクトに対する UPROPERTY 参照を保持する必要があります。多くの場合アクタはこの例外です。 
アクタは、通常、アクタが属するレベルなどのルートセットに戻ってリンクしているオブジェクトによって参照されているためです。アクタは、`Destroy()` で明示的に破棄とマーク付けすることができます。

## 参照の自動更新

ガーベジ コレクションによってオブジェクトがクリーンアップされると、オブジェクトへのUPROPERTY 参照は自動的に NULL に更新されます。これは、ダングリング ポインタが残らないようにし、今後トラブルが生じないようにするという点でメリットがあります。 
しかし、ポインタがポイントするオブジェクトが明示的に破棄とマーク付けされていれば、ポインタが予期せず NULL になりうることも意味します。従って、必ずテストを行ってから 
参照を解除するようにしてください。

この機能は、UPROPERTY とマーク付けされているオブジェクト参照にのみ適用されるということが重要です。Raw ポインタに格納されているオブジェクト参照は、アンリアル側では未知のものであり、 
自動的に NULL になったり、ガーベジ コレクションを妨げるようなことはありません。これは、すべての UObject* 変数が必ず UProperties でなければならないという意味ではないことにご注意ください。UProperty ではないオブジェクトのポインタが必要な場合は、TWeakObjectPtr<> の使用を検討してください。 
これは、弱いポインタであるため、ガーベジ コレクションを防ぎませんが、アクセスされる前に、有効性についてクエリされることが可能です。

## シリアル化

UObject がシリアル化されると、"transient" と明示的にマーク付けされていない限り、すべての UProperty 値が自動的に書き込みまたは読み出されます。例えば、AEnemy インスタンスをレベルに配置し、 
そのヘルスを 500 に設定して保存すると、UClass 定義以外に一行もコードを記述することなく、リロードできます。

UProperties が追加または取り除かれると、事前に存在していたコンテンツのロードがシームレスに処理されます。新規プロパティは、新規 CDO からコピーされたデフォルト値を取得します。取り除かれたプロパティは、警告なしに無視されます。

カスタムの振る舞いが必要ならば、カスタムのシリアル化を記述し、必要が生じたらコードをバージョニングできますが、これは実務上、一般的ではありません。

##プロパティ値を更新する

UClass の CDO を変更すると、アンリアル エンジンではこうした変更をロード時にクラスのすべてのインスタンスにインテリジェントに適用しようとします。任意のオブジェクト インスタンスについて、 
更新された変数が、その前のデフォルトから変わっていなければ、新しいデフォルト オブジェクトに更新されます。変数に何らかの変更があった場合、その値は意図的に設定されたものであるとみなされ、 
そうした変更は元に戻されません。

例えば、いくつかの AEnemy オブジェクトを配置したレベルを保存し、ヘルスのデフォルト値を AEnemy コンストラクタで 100 に設定したとします。さらに、Enemy_3 は特にタフであるため、
 ヘルスを 500 に設定したとします。

その後、気が変わって、ヘルスのデフォルト値を 150 に増やしたと想定します。次回、レベルをロードすると、アンリアル エンジンは、CDO が変更されたことを認識し、Enemy_3 以外は 150 のヘルス値を持つように、 
AEnemy のすべてのインスタンスを更新します。Enemy_3 のヘルスは 500 のままです。
 
##プロパティの自動初期化

コンストラクタが呼び出される前に、UObjects は初期化時に自動的にゼロになります。これはクラス全体、UProperties、ネイティブ メンバでも同様に起こります。続いて、クラス コンストラクタのカスタム値で 
メンバが初期化されます。

## エディタの統合

UObjects と UProperties はエディタによって認識されます。エディタはこうした値を編集のために自動的に公開します。特殊なコードを記述する必要はありません。これにはオプションで 
ブループリント ビジュアル スクリプティング システムへの統合が含まれます。変数と関数のアクセシビリティと公開を制御するためのオプションが数多くあります。

##ランタイム時の型情報

UObjects はどの UClass であるかを常に認識しており、ランタイム時に型関連の決定が行われます。 

ネイティブ コードでは、すべての UObject クラスは、その親クラスに設定されたカスタムの"Super" typedef を持ちます。これにより、挙動のオーバーライドを簡単に制御することができます。例えば、以下のようになります。


	class AEnemy : public ACharacter
	{
		virtual void Speak()
		{
			Say("Time to fight!");
		}
	};

	class AMegaBoss : public AEnemy
	{
		virtual void Speak()
		{
			Say("Powering up! ");
			Super::Speak();
		}
	};

ご覧になってわかるように、 Speak() を呼び出すと、 MegaBoss が"Powering up! Time to fight!" といいます。

さらに、テンプレート化された Cast 関数を使用して、基底クラスからのオブジェクトを派生クラスに安全にキャストできます。または、 IsA() を使用してオブジェクトが特定のクラスであるかをクエリすることができます。以下に簡単な例を示します。

	class ALegendaryWeapon : public AWeapon
	{
		void SlayMegaBoss()
		{
			TArray<AEnemy> EnemyList = GetEnemyListFromSomewhere();

			// この伝説の武器は、 MegaBoss に対してのみ効果があります。
			for (AEnemy Enemy :EnemyList)
			{
				AMegaBoss* MegaBoss = Cast<AMegaBoss>(Enemy);
				if (MegaBoss)
				{
					Incinerate(MegaBoss);
				}
			}
		}
	};

ここでは、Cast<> を使用して AEnemy を AMegaBoss にキャストしようとしています。問題となっているオブジェクトが実際には AMegaBoss (またはその子クラス) ではない場合、 
このキャストは NULL を戻し、適切に対応することができます。この場合、この伝説の武器は効果がありません。

##ネットワークのレプリケーション

UObject システムには、ネットワーク通信とマルチプレイヤー ゲームを行いやすくする堅牢な機能セットがあります。

UProperties をタグ付けして、アンリアル エンジンに対してネットワーク プレイ中にそのデータをレプリケートするように指示できます。この場合の一般的なモデルとしては、変数がサーバー上で変更され、続いてアンリアル エンジンがこの変更を検知し、 
すべてのクライアントに変更を確実に送信します。レプリケーションによって変数が変更する場合に、クライアントはオプションでコールバック関数を受信します。

リモートマシンで実行するように UFunctions もタグ付けできます。例えば、「サーバー」の関数は、クライアントのマシン上で呼び出されると、 
そのアクタのサーバーのバージョンに対して関数を実際にサーバーマシン上で実行させます。一方、「クライアント」の関数をサーバー側から呼び出して、そのアクタの所有しているクライアントのバージョンで実行します。
