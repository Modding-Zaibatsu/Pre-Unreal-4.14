INTSourceChangelist:2713515
Availability:Public
Title:ブループリントのマルチプレイヤー機能
Crumbs:%ROOT%, Gameplay, Gameplay/Networking
Description:ブループリントに適用するマルチプレイヤー機能のさまざまな側面
Related:Resources/ContentExamples/Networking
Related:Gameplay/Networking/Actors
version:4.9

[TOC (start:2 end:3)]

アンリアル エンジン 4 は、すぐに使用できる多数のマルチプレイヤー機能を内蔵していて、ネットワーク上で機能する基本的なブループリントゲームの設定を簡単に行えます。[すぐに作業を開始](Gameplay/HowTo/Networking/TestMultiplayer) してマルチプレイヤー ゲームをプレイできます。マルチプレイヤーを機能させる基本的なロジックのほとんどは `Character` クラスに内蔵されたネットワーキング サポートと、クラスの `CharacterMovementComponent` に関わっています。これはサードパーソン テンプレート プロジェクトに使用します。

## ゲームプレイ フレームワークのレビュー

ゲームにマルチプレイヤー機能を追加するには、エンジンが提供する主なゲームプレイ クラスの役割およびこれらが互いに機能する方法を理解することが必要です。特にマルチプレイヤー コンテキストでこれらが機能する方法が重要です。

* GameInstance
* GameMode
* GameState
* ポーン (および ポーンから継承するキャラクター)
* PlayerController
* PlayerState

 詳細は [フレームワークのオンライン マニュアル](Gameplay/Framework) をご覧ください。マルチプレイヤー機能を持つゲームをデザインする時は、すくなくとも以下の点に留意してください：

* GameMode オブジェクトはサーバーのみに存在します
* GameState はサーバーとクライアント両方に存在します。そのためサーバーはゲーム関連のデータ上で全てのクライアントを最新に保つために、GameState でレプリケートした変数を使用することができます。
* PlayerController はゲームに接続しているすべてのプレイヤーのためにサーバー上に存在します。クライアント側は、クライアントが所有するプレイヤーの PlayerController のみが存在します。つまり PlayerController はクライアントと利害関係があるレプリケート プロパティの格納場所に適していません。よって PlayerState を使用します。
* PlayerState は、ゲームと接続しているすべてのプレイヤーに対してサーバーとクライアント両方に存在します。このクラスは所有しているクライアントだけでなく、個々のプレイヤーの現行スコアなど、すべてのクライアントと利害関係があるレプリケート プロパティに使用することができます。
* Pawns (Characters を含む) もサーバーとすべてのクライアント上に存在し、レプリケートした変数とイベントを格納することも出来ます。特定の変数かイベントに PlayerState または Pawn を使用する決定は状況によりますが、PlayerState はプレイヤーが接続している間中存続するのに対し、Pawn は接続の間中ずっと存続しない可能性があることを念頭に置いてください。例えば、ゲームプレイ中にプレイヤー キャラクターが消滅してしまうと、このキャラクターがコントロールしていたポーンは破壊されて、プレイヤーがリスポーンされた時に新しいポーンが作成されます。

## アクタのレプリケーション

![](replicates.png)

UE4 のネットワークの構築のコアテクノロジーはアクタのレプリケーションです。`Replicates` フラグを true に設定しているアクタは、サーバーが自身と接続しているクライアントへ自動的に同期します。ここで重要な点は、アクタはサーバーからクライアントへレプリケートされるということです。クライアントからサーバーへアクタをレプリケートすることはできません。言うまでもなくクライアントはサーバーへデータを送信しなくてはいけません。データはレプリケートした "Run on server" イベントを通じて送信します。

具体例を説明する [ハウツーガイド](Gameplay/HowTo/Networking/ReplicateActor) と [アクタの完全レプリケーション](Gameplay/Networking/Actors) を参照してください。

### 権限

ワールド内のすべてのアクタは、接続するプレイヤーの 1 人がこのアクタに対する権限を有すると考えられます。サーバーに存在するすべてのアクタは、サーバーがこのアクタに対する権限を持ちます (レプリケートしたアクタすべてを含む)。結果として **Has Authority** 関数をクライアントで実行すると、そしてその時のターゲットがクライアントにレプリケートされたアクタの場合は false を返します。また、別のサーバーやレプリケートしたアクタのクライアント ビヘイビアを分岐させる簡単な方法として、便利な **Switch Has Authority** マクロを使用することもできます。

![](switch_has_authority.png)

### 変数

詳細パネルに表示されるアクタの変数には、変数のレプリケート方法を操作する **Replication** ドロップダウン リストがあります。

![](variable_replication.png)


| オプション | 説明 |
| ------ | ----------- |
| **None** | 新しい変数のデフォルト設定です。つまり値はネットワークからクライアントへ送信されません。 |
| **Replicated** | サーバーがこのアクタをレプリケートするとこの変数をクライアントへ送信します。値を受け取るクライアントの変数値は自動更新されるため、次のアクセス時にサーバーの値を反映します。リアルワールド ネットワーク上でプレイ中は、更新にネットワークのレイテンシーに応じた遅延時間が発生します。レプリケートした変数は、サーバーからクライアントへ一定方向のみ移動することを忘れないでください！クライアントからサーバーへデータを送信する方法は、「Events」セクションを参照してください。 |
| **RepNotify** | 変数は [replicated] オプションと同様にレプリケートしますが、 OnRep_<variable name> 関数はブループリントで作成します。変数の値が変更するたびに、エンジンは自動でこの関数をクライアントとサーバーにに呼び出すことができます。この関数はゲームの必要性に応じて自由な方法で実装できます ![](onrep.png) |

[region:note]
エンジンにビルトインされたクラスの変数のほとんどは、レプリケーションが既に有効になっています。そのためマルチプレイヤー コンテキストで多くの機能は自動的に機能します。
[/region]

変数をレプリケーションする具体例を説明する [ハウツーガイド](Gameplay/HowTo/Networking/ReplicateVariable) と [プロパティの完全レプリケーション](Gameplay/Networking/Actors/Properties) を参照してください。

### スポーンと破壊

レプリケートしたアクタをサーバーでスポーンすると、この動作はクライアントに伝達されて、クライアントもこのアクタのコピーを自動的にスポーンします。ただし一般的には、レプリケーションはクライアントからサーバーへ作成することはないため、レプリケートしたアクタがクライアントでスポーンされると、アクタはスポーンされたクライアントのみに存在します。サーバーもその他のクライアントも、アクタのコピーを受け取りません。一方で、スポーンしたクライアントはアクタに対する権限を持ちます。これはゲームプレイにほとんど影響しない表面的なアクタなどには有効ですが、ゲームプレイに影響を及ぼしたり、レプリケートが必要なアクタは、サーバーでスポーンすることをお勧めします。

サーバーでアクタが破壊されると、すべてのクライアントは対応するアクタのコピーを破壊するように、レプリケートしたアクタの破壊に似たシチュエーションです。クライアントは自身が権限を持つアクタを自由に破壊できます。つまり、他のプレイヤーにレプリケートされないため影響を及ぼすことがない、アクタ自身がスポーンしたアクタを破壊できます。クライアントが権限を持たないアクタの破壊を試みると、破壊リクエストは無視されます。ここでの重要なポイントは、レプリケートしたアクタを破壊する場合は、サーバー上で破壊する、ということです。これはアクタをスポーンする場合にも当てはまります。

## イベントのレプリケーション

ブループリントは、アクタとその変数のレプリケーションの作成に加えて、クライアントとサーバー全体でイベントを実行することができます。

具体例を説明する [関数のレプリケート方法](Gameplay/HowTo/Networking/ReplicateFunction) と [PRC について](Gameplay/Networking/Actors/RPCs) を参照してください。

[region:note]
RPC (リモート プロシージャ コール) の用語も併せてチェックしてみてください。ブループリントでレプリケートしたイベントは実質的にエンジン内部の RPC へコンパイルされて、これらが通常 C++ コードで呼び出されることに注意してください。
[/region]

### オーナーシップ

レプリケートしたイベントを含むマルチプレイヤー ゲームを作業時の重要な概念は、[指定アクタまたはコンポーネントのオーナーとみなされる] (Gameplay/Networking/Actors/OwningConnections) 接続はどれかという点です。目的を果たすために、"Run on server" イベントはクライアントが所有するアクタ (またはアクタのコンポーネント) からだけ呼び出せることに留意してください。通常は以下のアクタまたはアクタの 1 つのコンポーネントからのみ "Run on server" イベントを送信できることを意味します。
* クライアントの PlayerController 自身
* クライアントの PlayerController が所有するポーン、または
* クライアントの PlayerState

同様に "Run on owning client" イベントを送信するサーバーに対し、いずれかのアクタでこれらのイベントも起動しなくてはいけません。そうしないと、サーバーはイベントを送信するクライアントが分からないため、イベントはサーバー上のみで実行します！

### イベント

カスタムイベントの詳細パネルで、イベントのレプリケート方法を設定出来ます。

![](event_replication.png)

| オプション | 説明 |
| ------ | ----------- |
| **Not Replicated** | デフォルト設定。このイベントのレプリケーションは作成されないことを意味します。クライアントに呼び出された場合は、呼び出したクライアントのみで実行して、サーバーで呼び出された場合は、呼び出したサーバーのみで実行します。 |
| **Multicast** | マルチキャストイベントがサーバーに呼び出された場合は、ターゲットオブジェクトを所有する接続先に関係なく、イベントはすべての接続クライアントにレプリケートされます。クライアントがマルチキャスト イベントを呼び出した場合は、イベントはレプリケートされていないかのように扱われて、呼び出し元のクライアントのみで実行します。 |
| **Run on Server** | このイベントがサーバーから呼び出された場合は、イベントはサーバーのみで実行します。イベントがクライアントが所有するターゲットと一緒にクライアントから呼び出されると、イベントはサーバーへレプリケートされてここで実行します。"Run on Server" イベントはクライアントがサーバーへデータを送信するための基本的なメソッドです。 |
| **Run on Owning Client** | サーバーから呼び出されると、このイベントはターゲットアクタを所有するクライアントで実行します。サーバーはアクタ自身を所有できるため、名前の意に反して "Run on Owning Client" イベントは実際にサーバーで実行することもあります。クライアントから呼び出されると、イベントはレプリケートされていないかのように扱われて、呼出し元のクライアントのみで実行します。 |

以下の表は、呼ばれ方次第ではイベントの実行場所に影響を及ぼすさまざまなレプリケーションモードを示しています。

サーバーからイベントを呼び出した場合、左側のカラムをターゲットと仮定、そしてイベントの実行場所を順に表示しています。

|							| Not replicated	| Multicast					| Run on Server	| Run on Owning Client		|
| ---------------------		| --------------	| ---------					| -------------	| --------------------		|
| **Client-owned target**	| Server			| Server and all clients	| Server		| Target's owning client	|
| **Server-owned target**	| Server			| Server and all clients	| Server		| Server					|
| **Unowned target**		| Server			| Server and all clients	| Server		| Server					|

クライアントからイベントを呼び出した場合、左側のカラムをターゲットと仮定、そしてイベントの実行場所を順に表示しています。

|											| Not replicated	| Multicast			| Run on Server	| Run on Owning Client	|
| -----------------------------------------	| --------------	| ---------			| -------------	| --------------------	|
| **Target owned by invoking client**		| Invoking client	| Invoking client	| Server		| Invoking client		|
| **Target owned by a different client**	| Invoking client	| Invoking client	| Dropped		| Invoking client		|
| **Server-owned target**					| Invoking client	| Invoking client	| Dropped		| Invoking client		|
| **Unowned target**						| Invoking client	| Invoking client	| Dropped		| Invoking client		|


上記の表からもわかるように、クライアントから呼び出されて Run on Server を設定していないイベントは、レプリケートされていないかのように扱われます。

通常のアクタレプリケーションは「サーバーからクライアントへ」の一方向に設計されているため、レプリケートしたイベントの送信は、クライアントからサーバーへ情報を通信できる唯一の手段です。

マルチキャスト イベントはサーバーのみが送信可能であることにも留意してください。アンリアルのクライアント サーバー モデルを使用しているため、クライアントはその他のクライアントと直接接続していません。クライアントはサーバーだけと接続しています。そのため、クライアントはマルチキャスト イベントを直接他のクライアントへ送信することはできず、サーバーのみと通信しなくてはいけません。ただし、レプリケートした 2 つのイベントである Run on server イベントと Multicast イベントを使用すれば、このビヘイビアをエミュレートすることができます。Run on server イベントを実装することでバリデーションを実行して、必要に応じてマルチキャスト イベントを呼び出します。マルチキャスト イベントの実装は、接続しているすべてのプレイヤーで実行するロジックを実行します。バリデーションを一切実行しない例は、以下の画像をご覧ください。

![](forward_multicast.png)

#### 進行中のゲームへの参加を検討

ゲームステート変更を通信するためにレプリケートイベントを使用する時は、イベントと「join-in-progress」 (進行中のゲームへの参加) をサポートするゲームがどのように相互作用するか注意してください。ゲームの進行中にプレイヤーがゲームに参加すると、参加前に発生したレプリケートイベントは新しいプレイヤーには実行されません。ゲームと「join-in-progress」をうまく機能させるには、レプリケートした変数で重要なゲームプレイデータを同期させるのが最善です。よくあるパターンとして、クライアントがワールドでいくつかのアクションを実行、 "Run on server" イベントでアクションをサーバーに通知、そしてこのイベントの実装で、サーバーはアクションに基づいてレプリケートした変数をいくつか更新します。アクションを実行しなかったその他のクライアントは、レプリケートした変数を通じてアクションの結果を知ることができます。またアクション発生後に「join-in-progress」したクライアントは、サーバーからレプリケートした変数の最新値を受け取るため、ワールドの正確なステートを知ることができます。代わりにサーバーのみがイベントを送信すると、「join-in-progress」プレイヤーは実行されたアクションを知ることができません！

#### Reliability (信頼性)

レプリケートしたイベントは、**Reliable** または **Unreliable** のどちらかに設定できます。

Reliable イベントは目的地への到達が保証されているイベントですが、条件を満たすために多くの帯域幅を使用、およびレイテンシーが大きくなる可能性があります。Reliable イベントのエンジンの内部バッファがオーバーフローする可能性があるため、Reliable イベントの送信を、ティックの都度など頻繁にしないでください。オーバーフローが発生すると、関連するプレイヤーは非接続になってしまいます！

Unreliable イベントは名前が示す通りの機能を持ちます。つまり、ネットワーク上でパケットロスが発生した場合、またはネットワークに優先順位の高いトラフィックが多数存在すると判断した場合などは、イベントが目的地へ到達しない可能性があります。結果として、Unreliable イベントはReliable イベントよりも少ない帯域幅を使用し、より頻繁に安全に呼び出せます。
