INTSourceChangelist:2713555
Availability:Public
Title:Character Movement Component（キャラクター移動コンポーネント）
Crumbs:%ROOT%, Gameplay, Gameplay/Networking, Gameplay/Networking/Actors
Description:キャラクター移動コンポーネントについて
Related:Gameplay/Networking/Actors
version:4.9

[TOC (start:2 end:3)]

CharacterMovementComponent を利用するキャラクターには、自動的にネットワークの構築が組み込まれます。ネットワークゲームで CharacterMovementComponent を使用したプレイヤーの移動予測、レプリケーション、修正を行う方法は以下の通りです。

すべてのティックに TickComponent() 関数が呼び出されます。フレームの加速度と回転変更を計算してから、PerformMovement() (ローカルでコントロールしているキャラクターに) または ReplicateMoveToServer() (ネットワーククライアントの場合) を呼び出します。

ReplicateMoveToServer() は移動を保存 (PendingMove リスト)、PerformMovement() を呼出してから、レプリケート関数 ServerMove() を呼び出すことで移動をサーバーへレプリケートします。この関数で移動パラメータ、クライアントの合成位置、タイムスタンプを渡します。

ServerMove() はサーバーで実行されます。Movement パラメータをデコードして、適切な移動を発生させます。次に最終位置を見て、最後の応答から時間が経ちすぎている場合、または位置エラーが注目に値する場合は、サーバーはレプリケート関数 ClientAdjustPosition() を呼び出します。

クライアントで ClientAdjustPosition() を実行します。クライアントは自身の位置をサーバの位置に設定して、 bUpdatePosition フラグを true に設定します。

TickComponent() がクライアントに再び呼び出されると、 bUpdatePosition が true の場合は、クライアントは PerformMovement() を呼ぶ前に ClientUpdatePosition() を呼び出します。ClientUpdatePosition() は保留中の移動リストの移動全てをリプレイします。リストはサーバーが調整していた移動のタイムスタンプを記録した後に作成されます。

## キャラクター移動とシミュレーションしたプロキシ

これまでに説明した CharacterMovementComponent のネットワークの構築方法は、権限のあるサーバーと接続した 1 つのクライアントの詳細のみで処理しました。それでは、AI をサーバーへ移動したり、別の PC から他のプレイヤーを再生する場合はどうでしょう？クライアント マシーンはこれらすべてをシミュレーションしたプロキシとして扱い、多少異なるコードパスを移動します。

人間以外がコントロールするキャラクターの移動は、通常は標準の PerformMovement() コードを使用してサーバー (この例では権限者) で更新します。位置、回転、ベロシティに加えて他に選択したキャラクターの特定ステート (ジャンプなど) のいくつかは、通常のレプリケーション メカニズムを使用して別のマシーンへレプリケートされます。つまりすべてのフレームに必ずしもネットワークを使用するわけではありません。これらのキャラクターをリモート クライアントによりスムーズに表示するために、クライアント マシーンはシミュレーションしたプロキシに対して、新規データが到達するまでフレームごとにシミュレーション更新を実行します。他のリモート ヒューマン プレイヤーのローカル クライアント ビューに対しても同様です。リモートプレイヤーは自身の更新をサーバーに送信して、定期的にこのデータを他のすべてのプレイヤーにレプリケートします。

この更新は次の更新までの「間を埋める」ために、レプリケートしたステートを元に、移動の推定結果をシミュレートすることを意図しています。サーバーから送信された新しい位置にプロキシを配置して次の更新の到達を待たずに (将来的には数フレーム)、クライアントがベロシティと移動ルールを適用して各フレーム位置で更新をシミュレートします。別の更新が届くと、ローカル シミュレーションを効率よくリセットして、新しいシミュレーションを開始します。

シミュレートしたプロキシの移動更新のほとんどは、UCharacterMovementComponent::SimulateMovement() で実行して、同様にMoveSmooth() で実行します。ほとんどの場合、MoveSmooth() はさまざまな移動モードでのフル移動モード更新の最小バージョンです。この用途において実行コストが多少安く、複雑度も多少緩和します。

###シミュレートしたプロキシのスムージング

キャラクターが単に前進している場合は、直線の移動は予測がとても簡単なため、シミュレートした更新は次のレプリケート更新とほぼ一致します。ワールド内のスタティックなウォールへ向かって走る場合でさえ、偏差と後続の更新も高精度なシミュレーションとなります。

前のレプリケートステートスナップショットに基づいたローカルシミュレーションは、場合によっては実際の正確な位置と異なってしまいます。Time t=0、ベロシティ (100、0、0) で移動していたキャラクターのレプリケートステートを考えてみましょう。T=1 で更新した 1 秒後にシミュレートしたプロキシは、X 方向にさらに 100 単位移動します。ただし、サーバー側の実際の移動が (100、0、0) ベロシティ更新を送信後にすぐに停止した場合は、次のレプリケーションはサーバー バージョンのプロキシ位置をローカルでシミュレートしたスポットとは別のスポットに配置します。

サーバー更新の受信時に、シミュレートしたプロキシの位置がビジュアル的に「飛び出さない」ように、キャラクターのメッシュ (コリジョン表現に使用したシンプルな形状ではなく、ボディの複雑なビジュアル表現) の位置を UCharacterMovementComponent::SmoothClientPosition() 関数を利用してスムーズにします。特定の時間内にターゲットの目的地へ到達するために、シンプルなスムージング関数をデフォルトで適用します (クライアントのネットワークデータに "SmoothNetUpdateTime" で設定)。

##CharacterMovementComponent ネットワーキングのデバッグ作業

キャラクター ネットワーキングのデバッグ作業と分析を行う際に便利なツールがいくつかあります。通常、まず最初に、不規則な動作をしているクライアントのコンソールに "p.NetShowCorrections 1" を入力することから始めます (出荷ビルドを除いて機能します)。この機能をサーバー側でも有効にすると、便利かもしれません。出力コンソールへのロギングと、「正しい」位置 (緑) と「不正」な位置 (赤) にコリジョン形状の描画両方を行うことで、クライアント (またはサーバーへ送信) がネットワーク修正を受け取った時期が常にわかるようになります。クライアントにとっての「正しい」位置とはサーバーから修正として送信された位置になります。一方で「不正」な位置とはサーバー側で誤差許容外と判断されたローカル位置になります。サーバー側も同様の考え方です。「正しい」サーバーの位置は緑で描画されながら、「不正」な受信したクライアント位置は赤で描画されます。 "p.NetCorrectionLifetime" は、デバッグ ビジュアライゼーションが表示されなくなるまでワールド内に持続する時間 (秒) をコントロールします (例えば "p.NetCorrectionLifetime 5" は 5 秒間持続させます)。

問題の診断に有用なその他の方法は、CharacterMovement networked movement 関数が送信したデータのロギングの一部をオンにします。コンソール コマンド "log LogNetPlayerMovement Verbose" は、位置、回転、加速度を含めてキャラクター移動の送受信データをロギングします。サーバー側のロケーション変更がクライアントと同じ方法で行われなかったために、クライアント側のみで位置が更新される場合など、なぜエラー修正が発生するのかこれで説明がつきます。

##高度なトピック新しい Movement アビリティをキャラクター移動へ追加する

キャラクターへ新規の移動アビリティを追加する方法は多数あります。ネットワークゲームで機能するキャラクターに "Teleport" アビリティを追加する一連の試みをステップスルーしてみましょう。基本的な考えは、プレイヤーが **T** キーを押すと、目的地に障害物がない限りキャラクターは 10 メートル前方へテレポートします。

###手法その 1:クライアントのみで実行
このアプローチはネットワーキングを一切考慮せず、**T** キーが押された時に前方へテレポートするだけです。

**結果**:ネットワークゲームで失敗します。ローカル クライアントは前方へテレポートしたように表示されますが、すぐに開始位置へワープして戻ります。

**分析**:ネットワーキングに対し特に何もしない単なる基準値で、失敗することが分かっています。なぜでしょう？サーバーはアビリティがトリガーされたことを識別できないため、移動をトリガーするためにクライアントの位置、回転、加速度のみと連携しているからです。そのためサーバーの視点からは、キャラクターが前進しても意味がありません。

###手法その 2:サーバーだけに RPC を呼び出す
ネットワークゲームで機能する一番シンプルなアプローチは、アビリティをトリガーするために信頼できるネットワーク RPC を設定することです。この場合、テレポートするために Server 関数のみを呼び出します。

**結果**:ネットワークゲームで機能しますが、クライアント側で実行時に著しい遅延が発生したり、テレポート機能をいくつか失うなど深刻な問題があります。

**分析**:動作はしますが理想には程遠いです。以下はイベントのシーケンスです。サーバーはプレイヤーを前方へテレポートさせる関数コールを受け取ります。クライアントのキャラクター移動更新は、テレポートしていない位置がサーバーへ送信されます。サーバー側のテレポートは RPC を通じて行うため、サーバーはこれをエラーとみなします。サーバーはクライアントに修正を送信して、クライアント位置はまるでテレポートしたかのように変更します。(デバッグのヒント：クライアント側の移動はネットワーク修正の結果であることがわかったので "p.NetShowCorrections 1" コマンドが役立ちます。)

ネットワークラグの発生がここでも悩みの種となります。実際にはローカルマシーンでテレポートを発生させるために、クライアントからサーバーへ、そしてサーバーからクライアントへ戻る往復の時間をクライアントは待機しなくてはいけないためです。これでは、プレイヤーにとって満足なゲーム体験とはなりません。この問題に加えて、アビリティをローカルで実際に実行することは決してないため、「Teleport」アビリティで発生する追加の機能が、クライアント側で一切トリガーされない可能性もあります。例えば、目的地でサウンドとパーティクルエフェクトを再生した場合、クライアント側でこれらの効果は失われてしまいます。

###手法その 3:サーバー RPC とローカル トリガー
このアプローチはクライアントで Teleport アビリティを実行してから、テレポートを行うためにサーバー RPC を呼び出します。

**結果**:ネットワークゲームで機能しますが、まれに深刻な問題を引き起こす可能性があります。

**分析**:このアプローチは、前回の試みで生じた障害を改善しようとします。ここで言う障害とは、ローカル移動で生じる遅延と、アビリティではなく修正が原因で移動が発生することを指しています。サウンドやパーティクルエフェクトなど、Teleport のフル機能を活用できます。うまく機能しますがいくつかの重要な注意事項があり、実際のネットワーク環境ではいまだに中断してしまいます。

主な問題は、テレポートがトリガーされた時間よりも前の時間にクライアントの時間が戻されると、通常の時間に戻った際に Teleport アビリティを再度トリガーしなくてはいけないことがわからなくなり、Teleport がクライアント側で紛失してしまったように見えるからです。

###手法その 4:CharacterMovementComponent アビリティの実装
このアプローチは、ネットワーク修正を確実に行うために Teleport アビリティの知識を CharacterMovementComponent コード (子クラス) に追加します。

**結果**:ネットワークゲームで機能しますが、実装時にいくつか配慮が必要です。 

**分析**:先にも述べたように、このアプローチはもう少し背景が必要ですが、 CharacterMovementComponent を使用したキャラクターは "a saved move list" または "pending move list" と呼ばれる入力の結果、待ち行列に入ります (C++ コードではこれらの動作はクラス "FSavedMove_Character" から派生します)。保存したそれぞれの動作は、フレーム用に動作の開始時に位置、回転、加速度 (通常はプレイヤー入力の結果として)、ジャンプなどのステートを記録します。

移動がクライアントからサーバーへ送信されると、移動はサーバーによって認識されるため、受信した移動を保持して前の移動は除去されます (サーバーからのビューは、実際の直接ビューより少しだけ後方になります)。修正の場合、時間内のどこで発生したかが分かっていて、発生よりも後に起こったすべての移動を「再プレイ」することができます。修正時から時間内に再び前進しようと試みるため、クライアントは修正があったことさえ気づかないので、これは最適です。修正後にトリガーされたアビリティもまた再プレイできることを意味します。アビリティが再びトリガーされても一部のエフェクトを再度トリガーしないように、このケースの場合、おそらくアビリティにチェックが必要だと思います (例は UCharacterMovementComponent::DoJump() 関数の "bReplayingMoves" パラメータを参照)。

ここで "Teleport" アビリティの追加作業に戻りましょう！追加作業は CharacterMovementComponent で既に処理したジャンプと類似した方法で行います。このアビリティがトリガーされたことと、サーバー側で正しく処理したことを示すだけです。クライアントの反応を早くするために、もちろんアビリティはローカルで実行します。クライアントとサーバー間のデータの送受信は既存ネットワーキングの一部として行います。ユーザーはデータをパック/アンパックするだけです。

最初に UCharacterMovementComponent クラスから派生させて、その後独自の FSavedMove_Character バージョンを作成するために AllocateNewMove() をオーバーライドします。この時点でいくつかのメソッドを FSavedMove_Character に実装しなくてはいけません。最も重要なのが、 Teleport アビリティのトリガーを示すデータのビットをパックする GetCompressedFlags() です。その後サーバー側でフラグのアンパックとアビリティのトリガーを処理する UCharacterMovementComponent::UpdateFromCompressedFlags() をオーバーライドします。

以上がほぼすべての作業です！CharacterMovementComponent を保存した動作にカスタムフラグを実装すると潜在的にかなりの複雑性が潜んでいますが、正しいパスで開始するはずです。移動に堅牢なネットワーキングが必要であれば、価値のある作業です。
