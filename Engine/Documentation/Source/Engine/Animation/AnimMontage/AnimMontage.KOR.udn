INTSourceChangelist:2744667
Availability:Public
Title:애님 몽타주
Crumbs: %ROOT%, Engine, Engine/Animation
Description:AnimMontage, 애님 몽타주란 무엇이며 UE4 의 애니메이션 시스템에서는 어떻게 사용되는지에 대한 정보입니다.
Related: Engine/Content/FBX/Animations
Related: Engine/Content/Types/SkeletalMeshes
Related: Engine/Animation/PhysicallyDrivenAnimation
Related: Engine/Animation/StateMachines
Related: Gameplay/AI
Related: Engine/Content/Tools/MayaRiggingTool
Related: Gameplay/Input
version: 4.9

[TOC(start:2 end:2)]

[EXCERPT:Intro]
**Animation Montage** (애니메이션 몽타주, 혹은 줄여서 그냥 몽타주)는 폭넓은 애니메이션 이펙트가 가능해지는 다목적 툴로써, 주로 코드나 [블루프린트 비주얼 스크립트](Engine/Blueprints) 안에 애니메이션 콘트롤을 노출시키는 데 관련되어 있습니다. 애니메이션의 지능형 루프, 로직 기반 애니메이션 전환, 루트 모션 핸들링, 기타 여러가지 다양한 애니메이션 이펙트를 만드는 데도 사용 가능합니다.
[/EXCERPT:Intro]

_애님 몽타주_ 는 **콘텐츠 브라우저** 안에서 만들어 그 안에서 확인할 수 있는 애니메이션 애셋입니다. 이 애셋을 실행 시간에 애님 그래프에 직접 꽂으면 그 상태를 변경할 수 있습니다. 예를 들면, 다른 섹션으로 점프한다던가 다른 섹션으로 다시 연결할 수 있는 것입니다. 이는 거의 코드 주도형 애니메이션 또는 근접 공격같은 일회성 애니메이션의 경우로, 트리거를 제어하거나, 원할 때 멈추거나, (루프 또는 논루프) 상태 전환이 가능합니다 (아래 그림 참고).

몽타주에는 애니메이션에 루트 모션이 켜진 경우 네트워크 게임에서의 [](Engine\Animation\RootMotion\) 리플리케이션도 지원합니다.


## 몽타주 예제

![](Montage_Screen2.png)

위 그림은 세 가지 [시작, 루프, 끝] 섹션으로 된 근접 공격입니다. 플레이어가 **좌클릭** 하면, 기본적으로 _Start_ 섹션을 발동시켜 몽타주 재생을 요청합니다. 이제 중간 섹션은 _Loop_, 반복 설정되어 있습니다. 시작 섹션이 완료되면 루프로 전환한 뒤 영원히 반복합니다. 플레이어가 버튼을 놓으면, 중지를 할 테지만, 애니메이션이 루프 중간에 튀어 보일테니 바로 중지하지는 않습니다. 루프를 _End_ 로 전환하여 애니메이션을 마무리할 수 있도록 재연결해 주는 것이 좋을 것입니다.

추가적으로 몽타주가 사용되는 예는 다음과 같습니다:
* 애님 블루프린트의 이벤트 그래프 안에서 애니메이션 재생
* 복잡한 애니메이션 시퀀스를 엮어 하나의 애니메이션으로 간주
* 코드나 블루프린트 스크립트를 통해 애니메이션의 특정 부분이나 다수의 애니메이션 루프
* 코드나 블루프린트 스크립트를 통해 다수의 애니메이션에 대한 이벤트 기반 전환 처리
* 복잡한 애니메이션 시퀀스를 네임드 슬롯에 할당하여 코드나 블루프린트에서 전환
* 코드나 블루프린트 스크립트를 기반으로 다양한 애님 시퀀스 사이의 정교한 전환

[REGION:note]
캐릭터에 적용된 몽타주는 [애니메이션 콘텐츠 예제](Resources\ContentExamples\Animation) 페이지의 1.5 섹션 아래에서도 확인할 수 있습니다.
[/REGION]


## 몽타주 프로퍼티

애님 몽타주 애셋 프로퍼티에 대한 분석은 다음과 같습니다. 페르소나에서 몽타주를 확인할 때 사용할 수 있으며, 콘텐츠 브라우저에서 몽타주에 우클릭하여 나타나는 맥락 메뉴에서 _프로퍼티_ 를 선택해서도 접근할 수 있습니다.

![](MontageProperties.png)

|몽타주 프로퍼티||
|---|---|
|[REGION:tablesection]몽타주[/REGION]||
|**Blend In Time**|블렌드 인 시간 - 몽타주 재생 시작시 캐릭터가 현재 포즈에서 대상 포즈로 블렌드 인 해 들어가는 동안의 기간입니다. |
|**Blend Out Time**|블렌드 아웃 시간 - 몽타주 재생 종료시 캐릭터가 원래 포즈로 블렌드 아웃해 돌아가는 동안의 기간입니다. |
|**Blend Out Trigger Time**| 블렌드 아웃 트리거 시간 - 시퀀스 끝에서 블렌드 아웃 트리거까지의 시간입니다. < 0 은 BlendOutTime 을 사용하므로, BlendOut 은 몽타주가 끝나면 같이 끝이 납니다. > = 0 은 SequenceEnd-BlendOutTriggerTime 을 사용해서 블렌드 아웃을 트리거시킵니다. |
|[REGION:tablesection]애디티브 세팅[/REGION]||
|**Preview Base Pose**|베이스 포즈 미리보기 - 애디티브 블렌드 스페이스에 사용되는 베이스 프리뷰 포즈를 설정합니다. |
|[REGION:tablesection]애니메이션[/REGION]||
|**Rate Scale**|속도 스케일 - 몽타주의 재생 속도에 대한 배수입니다. 기본값은 1.0 입니다. |
|**Skeleton**|스켈레톤 - 이 몽타주에 관련된 스켈레톤이 들어있습니다. 에디터에서는 바꿀 수 없습니다. |
|[REGION:tablesection]메타 데이터[/REGION]||
|**Meta Data**| 메타 데이터 - 애셋과 함께 저장할 수 있는 메타 데이터입니다. Meta Data 는 Anim Meta Data 클래스에서 파생된 Blueprintable 클래스입니다. 이를 통해 애니메이션 애셋 (애님 시퀀스, 애님 몽타주, 애님 컴포짓, 블렌드 스페이스 모두 지원) 에 커스텀 메타 데이터를 추가시킬 수 있습니다. 애니메이션 애셋에 있는 데이터 쿼리는 C++ 에서 `GetMetaData()` 메소드를 호출하거나, 애님 몽타주에서 `GetSectionMetaData()` 를 사용하면 됩니다. |
|[REGION:tablesection]썸네일[/REGION]||
|**Orbit Pitch**| 공전 핏치 - 애셋 주변을 공전하는 카메라의 핏치(상하) 입니다. |
|**Orbit Yaw**| 공전 요 - 애셋 주변을 공전하는 카메라의 요(좌우) 입니다. |
|**Orbit Zoom**| 공전 줌 - 애셋과의 바운드 구체 거리에 적용할 오프셋입니다. |

## 몽타주 UI

페르소나에서 몽타주를 확인할 때, 각 부분이 무엇이고 어떤 역할을 하는지 알아두면 좋습니다:

[REGION:raw]
![](MontageUI.png)
[/REGION]

1. [몽타주 영역](#몽타주영역)
1. [섹션 영역](#섹션영역)
1. [엘리먼트 타이밍 영역](#엘리먼트타이밍영역)
1. [노티파이 영역](#노티파이영역)
1. [커브 영역](#커브영역)

## 몽타주 영역

몽타주 영역은 다음과 같이 나뉩니다:

[REGION:raw]
![](MontageArea.png)
[/REGION]

1. **Section Track** 섹션 트랙 - 이 몽타주에 대해 정의된 [섹션](#섹션) 이 있으면 표시해 줍니다. 섹션은 마우스 왼쪽 버튼으로 타임라인 상의 다른 위치에 이동시킬 수 있습니다.
1. **Slot Track** 슬롯 트랙 - 현재 [슬롯](#슬롯) 과, 그 이름을 오른쪽에 표시합니다. 이 슬롯은 원하는 만큼의 애니메이션으로 채울 수 있으며, 순서대로 재생됩니다. 참고로 다수의 애니메이션이 있을 경우 슬롯 트랙에 표시되는 위치가 달라집니다. 먼저 위에 있다가 다음에는 아래로, 다시 위로 식입니다. 각기 다른 애니메이션의 구분을 돕기 위해서입니다.

[REGION:note]
하나의 몽타주에 원하는 수 만큼의 슬롯 트랙을 넣을 수 있으며, 각 트랙마다 자체적인 이름과 고유의 애니메이션이 들어 있습니다. 그러나 섹션 트랙은 각 몽타주에 대해 하나씩만 있을 수 있습니다.
[/REGION]


### 섹션

몽타주 섹션은 하나의 슬롯을 다수의 애니메이션 부분으로 나눌 수 있는 수단이 됩니다. 각 섹션은 슬롯의 타임라인 안에 이름과 위치가 있습니다. 그 이름을 사용해서 특정 섹션으로 바로 점프하거나, 현재 부분의 재생 완료시 다음에 재생할 큐에 등록시킬 수도 있습니다. 블루프린트에서 현재 섹션 질의, 어느 한 섹션으로 점프, 다음에 재생할 섹션 설정 등이 가능합니다.

섹션은 음악 재생목록의 노래, 슬롯은 앨범으로 생각해 보면 쉽습니다. 최근의 미디어 플레이어가 그렇듯이, 현재 곡의 재생이 완료되면 다음에 재생할 곡을 선택하거나, 바로 다음 곡으로 점프할 수도 있습니다.

섹션의 생성은 섹션 트랙에 우클릭한 다음 **New Montage Section** (새 몽타주 섹션)을 선택하면 됩니다.


### 슬롯

[EXCERPT:Slots]
몽타주 안의 **Slot** (슬롯)은 하나의 트랙으로, 여기에는 애니메이션을 몇 개든 담을 수 있습니다. 이 슬롯에는 이름을 지을 수 있으며, 나중에 그 슬롯 이름을 호출하여 지정된 애니메이션으로 블렌딩해 들어갈 수 있습니다. 캐릭터의 무기 재장전 애니메이션이 좋은 예입니다. 플레이어가 서 있을 때, 웅크리고 있을 때, 누워 있을 때 각기 다른 버전의 재장전 애니메이션을 준비할 수 있겠죠. 세 가지 애니메이션 모두 같은 타이밍을 사용한다는 가정 하에, 그 각각을 몽타주 내 별도의 슬롯에 넣고서, 그 슬롯 이름을 _Standing_, _Crouching_, _Prone_ 으로 짓습니다. 애니메이션 블루프린트의 애님 그래프에서 _Slot_ 노드를 사용하여 캐릭터의 현재 상태에 따라 재생하고자 하는 슬롯을 결정할 수 있습니다. 서있을 때는 _Standing_ 슬롯의 애니메이션 결과를 사용할 수 있습니다. 누워 있을 때는 _Prone_ 슬롯의 결과를 보면 됩니다.

한가지 유념해야할 중요한 점은, 몽타주 콘트롤의 다수가 애니메이션 블루프린트의 _이벤트 그래프_ 안에서 벌어짐에도 슬롯은 실제 _애님 그래프_ 안에서 처리된다는 점입니다. 이는 Slot 노드를 사용하는 식으로 이루어지며, 거기서는 단순히 슬롯 이름을 받을 뿐입니다. 애님 그래프의 실행상 전략적인 지점에 이 노드를 배치하는 것으로, 다수의 몽타주에 같은 슬롯 이름을 활용하도록 할 수 있습니다.
[/EXCERPT:Slots]

<!---------------- Branch moved to Notify page.
### 브랜치 포인트

브랜치 포인트(분기점)는 애니메이션 재생과 동시에 일어나는 이벤트를 만들 수 있습니다. 이러한 브랜치 포인트 이벤트는 코드나 블루프린트에서 다른 일이 발생하도록 만드는 데 사용할 수 있으나, 브랜치 포인트가 특히나 좋을 때는, 몽타주 안에서 다른 애니메이션 섹션으로 변경할 때 입니다.

[애니메이션 노티파이](Engine/Animation\Sequences\Notifies) 에 이미 익숙하신 경우, 이 두 시스템이 매우 비슷하다는 느낌을 받으실 수 있습니다. 둘 다 스크립트에서 활용할 수 있는 이벤트를 노출시키기 때문입니다. 핵심적인 차이점이라면, 노티파이는 _비동기식_, 브랜치 포인트는 _동기식_ 이라는 점입니다. 최종 사용자 입장에서 보자면, 브랜치 포인트로는 애니메이션 타임라인 상에서 어떠한 일이 발생하는 지점을 훨씬 더 정밀하게 지정할 수 있다는 점입니다.

높은 정밀도는 타임라인 내 매우 정밀한 순간에 특정 애니메이션 지점으로 점프할 필요가 있을 때 중요합니다. _노티파이_ 를 사용해서도 같은 작업을 할 수는 있지만, 노티파이의 비동기적 속성때문에 노티파이 이벤트가 잘못된 애니메이션 프레임에 발동되어 모션에 버벅임이나 끊김이 발생할 수 있다는 뜻입니다.

[REGION:warning]
브랜치 포인트의 동기적 속성과 그에 따른 정밀도로 인해, 노티파이 보다는 퍼포먼스 비용이 비쌉니다. 그렇기에 애니메이션 타임라인 상의 정교한 순간에 _반드시_ 발동되어야만 하는 이벤트, 이를테면 프레임 단위로 일치하는 다른 애니메이션에 직접 점프하는 경우에만 사용해야 할 것입니다. 한 프레임이나 그 몇 퍼센트 정도 어긋나는 것이 중요치 않다면 _노티파이_ 를 대신 사용하는 것이 좋습니다.
[/REGION]

-------------------->

## 섹션 영역

섹션 영역은 몽타주 영역에 정의한 섹션간의 관계를 설정할 수 있는 곳입니다. 예를 들어 애니메이션의 특정 섹션(이나 섹션 그룹)을 특정 시퀀스나 심지어 반복 재생시키고자 하는 경우입니다.

[REGION:raw]
![](SectionsArea.png)
[/REGION]


1. **Create Default and Clear Buttons** 디폴트 생성 / 비우기 버튼 - 디폴트는 모든 섹션간의 기본적인 관계를 생성, 서로간의 관계를 엮어 줍니다. 비우기는 모든 관계를 지워버립니다.
1. **Section Buttons** 섹션 버튼 - 이 영역에는 몽타주 영역에 정의한 각 섹션의 버튼이 보입니다. 기존 섹션을 선택한 다음 이 버튼 중 하나를 클릭하면, 해당 버튼에 대한 섹션을 선택된 트랙에 연결해 줍니다. 예를 들어 위 그림에서, _Swing2_ 에 _Swing1_ 을 연결해 줬습니다. 실제 순서는 _Swing1_, _Swing2_, 다음 _Swing1_ 이 다시 와서 루프가 됩니다. 자세한 것은 아래 [루핑](#루핑) 부분을 참고해 주시기 바랍니다.
1. **Section Association Tracks** 섹션 연결 트랙 - 애니메이션 섹션간의 관계를 시각화시켜 미리볼 수 있는 곳입니다. **Preview** (미리보기) 버튼을 클릭하면 각 개별 트랙의 결과를 확인할 수 있고, **Preview All Sections** (모든 섹션 미리보기) 버튼을 클릭하면 모든 섹션을 차례대로 재생시켜 볼 수 있습니다.

### 루핑

섹션은 무한 루프 설정이 가능하여, 반복시키고자 하는 동작이 있을 경우에 매우 좋습니다. Section Association (섹션 연결 트랙)에 동일한 섹션을 두 번 이상 연결시켜 주면, 해당 섹션이 루프로 실행되게 됩니다. 루프가 된 섹션은 파랗게 표시됩니다. 예를 들어 캐릭터가 샷건 총알을 한 번에 한 발씩 재장전하는 애니메이션을 생각해 봅시다. 캐릭터가 총알을 삽입하는 섹션만 잡아다가 루프를 겁니다. 그 후 노티파이를 사용해서, 애니메이션 재생이 한 번 끝날 때마다 탄환 카운트를 늘리도록 하는 노티파이 이벤트를 블루프린트에서 만듭니다. 카운트가 설정된 (최대 탄환) 수에 도달하면, 캐릭터는 리시버를 닫는 애니메이션으로 전환시킨 다음 빈둥 상태로 돌아갑니다.

## 엘리먼트 타이밍 영역

Element Timing Area (엘리먼트 타이밍 영역)은 몽타주 영역과 노티파이 영역에서 정보를 받아 여러 섹션의 타이밍에 도움을 줍니다.

![](ElementTiming1.png)

트랙의 각 노드에 주어지는 수치를 통해 전체 몽타주에서 해당 오브젝트의 발동 순서가 정해지며, 그에 맞게 색이 주어집니다. 색 기본값은 다음과 같습니다:
* 빨강 - 노티파이, 스테이트 노티파이 및 스테이트 엔딩 마커 노티파이 입니다.
* 연한 파랑 - 브랜칭 포인트 노티파이 입니다.
* 초록 - 몽타주 섹션입니다.

[REGION:note]
이 색은 **에디터 개인설정** 아래에서 찾을 수 있는 **애니메이션 에디터** 부분에서 설정 가능합니다.
[/REGION]

트랙의 노트에 커서를 올리면 그 노드가 무슨 뜻인지 설명해 주는 툴팁이 나타납니다.

![](ElementTiming2.png)

트랙 오른편의 드롭다운 메뉴를 통해 여러가지 엘리먼트의 표시여부를 토글시킬 수 있습니다.

![](ElementTiming3.png)

## 노티파이 영역

![](NotifiesArea.png)

[INCLUDE:Engine/Animation/Sequences\Notifies#Intro]

[REGION:note]
자세한 정보는 [](Engine/Animation\Sequences\Notifies) 문서를 확인해 주시기 바랍니다.
[/REGION]

## 커브 영역

![](CurvesArea.png)

[INCLUDE:Engine/Animation/Sequences\Curves#Intro]

[REGION:note]
자세한 정보는 [](Engine/Animation/Sequences\Curves) 문서를 참고하시기 바랍니다.
[/REGION]


## 몽타주 재생

몽타주는 여러가지 방법으로 재생 가능합니다:

* **스켈레탈 메시** 의 **재생할 애님** 에 할당할 수 있습니다.
* **블루프린트** 스크립트나 C++ 를 통해 직접 호출 가능합니다.
* **애니메이션 블루프린트** 의 일부로써 **애니메이션 그래프** 안에 포함시킬 수 있습니다.

[REGION:note]
애니메이션 블루프린트 안에서의 몽타주 사용 방법 예제는 [](Engine/Animation/AnimHowTo/AdditiveAnimations) 문서를 참고하세요. 한 캐릭터에 별개의 두 애니메이션을 동시에 재생시키는 방법을 보여주고 있습니다 (여기서는 캐릭터가 이동하면서 동시에 총을 쏘고 있습니다).
[/REGION]

### 다중 몽타주 재생

언리얼 엔진 4.6 전에는 한 번에 하나의 몽타주만 재생할 수 있었습니다. 그러나 4.6 버전 이후로 **애님 슬롯** 또는 **애님 그룹** 을 사용하여 원하는 만큼의 몽타주를 재생하는 것이 가능해 졌습니다.

그 작동방식을 간단히 살펴보면 이렇습니다:

* 애니메이션을 애님 그룹으로 체계적으로 정리해 넣습니다. 그룹별로 하나의 몽타주를 재생할 수 있습니다. 동시에 다른 몽타주를 재생하고자 하는 경우, 그에 대한 애님 그룹을 새로 만들어 주면 됩니다.
* 애님 그룹 & 애님 슬롯은 **페르소나** 안의 **애님 슬롯 매니저** 안에 모여 있습니다 (아래 [애님 슬롯 매니저](#애님슬롯매니저) 참고).
* 드롭다운 UI 를 사용하여 유효한 슬롯을 선택할 수 있습니다.
* 새 몽타주를 만들 때, 슬롯 노드는 하나의 **디폴트 슬롯** 이 기본적으로 제공되어 바로 사용할 수 있습니다.

### 애님 슬롯 매니저

**Anim Slot Manager** (애님 슬롯 매니저)는 애님 슬롯 & 애님 그룹 이름을 관리하는 곳입니다. 계층형 뷰로 표시되어 쉽게 변경할 수 있습니다. **페르소나** 에서 몽타주 내 애님 슬롯 매니저를 열 수 있는데, 돋보기 아이콘(아래 그림)을 클릭하면 됩니다.

![](OpenAnimSlotManger.png)

그러면 애님 슬롯 매니저가 열립니다.

![](AnimSlotManager.png)

그룹과 슬롯은 **스켈레톤** 애셋에 저장되므로 동일군의 모든 애니메이션 블루프린트와 몽타주는 같은 세팅을 사용할 수 있습니다. 애님 슬롯 매니저에 **저장** 버튼이 있어 편집할 때마다 스켈레톤 애셋에 쉽게 저장할 수 있습니다.

슬롯 이름에 **우클릭** 하면 맥락 메뉴가 떠 원하는 다른 그룹으로 이동시킬 수 있습니다. 이를 통해 이미 생성하여 배치한 슬롯을 관리하여 다른 그룹으로 옮기면서 원하는 대로 재배치할 수 있습니다.

![](SlotClicking.png)

### 몽타주 트랙의 슬롯 편집

아래는 **페르소나** 안의 **몽타주 에디터** 예제로, (강조된) 드롭다운 박스에는 해당 트랙에 사용할 수 있는 슬롯이 나열됩니다.

![](SlotExample1.png)

슬롯이나 그룹을 새로 만들 필요가 있는 경우, 돋보기 아이콘을 클릭하면 **애님 슬롯 매니저** 로 이동합니다.

상단의 상태바를 통해 몽타주가 속한 그룹을 알 수 있습니다. 이는 첫 트랙의 슬롯으로 결정됩니다.

![](SlotExample2.png)

슬롯이 여럿 있는 경우, 상태바는 구성상에 문제가 있는 것이 아닌지 알려주기도 합니다. 예를 들어 다른 그룹에 속하는 슬롯을 섞어 일치시키는 경우 경고창이 뜨며, 그 위에 커서를 올리면 해당 문제 관련 자세한 정보를 확인할 수 있습니다.

![](SlotExample3.png)

### 애님 블루프린트의 슬롯 편집

애니메이션 블루프린트의 애님 그래프 안에서는 **Slot** 노드를 추가할 수 있으며, 선택시 몽타주 트랙 뷰에 표시되는 것과 같은 옵션을 확인할 수 있습니다.

![](SlotNode.png)

여기서 드롭다운 박스를 사용하여 기존 슬롯 이름을 선택한 뒤 돋보기 아이콘으로 애님 슬롯 매니저를 열 수 있습니다.

추가 참고사항: 

* 기존 구성과의 하위 호환성이 유지됩니다. 기존 슬롯이 "디폴트 그룹"에 속하는 것 말고는 별다른 변화를 느끼지 못할 것입니다.
* 몽타주 블루프린트와 C++ API 가 몽타주 애셋 레퍼런스를 받도록 강화되었습니다. 이를 통해 동시에 여러 몽타주 재생을 제어할 수 있습니다. 예로 **Montage Set Play Rate** 함수를 참고하시기 바랍니다.


<!-------------------- Example removed. This should be a HowTo.

## 몽타주 실전 예제


이 예제에는 모든 방향으로 자유로이 뛰어다니면서 공격 애니메이션은 상체에서만 재생되는 캐릭터가 있습니다. 이 공격은 그 중간에 벌어질 수 있는 여러가지 애니메이션을 갖게 됩니다. 몽타주의 조합을 나타내는 데는 물론 이벤트 그래프에서 제어하는 방법이나 애님 그래프 안에서 블렌딩해 들어가는 방법을 보여주기에 완벽한 방법입니다.

그러나 미리 구성해 둬야 하는 것이 몇 가지 있습니다:

* 이미 스테이트 머신 정의 보행이 있습니다. Third Person Project 템플릿에서 사용된 것과 똑같은 것입니다.
* 아티스트가 제공해 준 애니메이션이 여럿 있어, 서로 엮어서 몽타주를 만들면 좋습니다.
* 입력 정보를 받아올 수 있는 [캐릭터 블루프린트 클래스](Engine\Blueprints\UserGuide\Types\ClassBlueprint\Creation) 를 생성했습니다.
 * 이 예제에서 **IsAttacking** 불리언은 **마우스 왼쪽 버튼** 이 눌리면 TRUE 로, 떼면 FALSE 로 설정됩니다.
  ![](CharacterBlueprint.png)

### 몽타주 생성

몽타주 생성은 쉽게 콘텐츠 브라우저에 우클릭한 다음 **애니메이션 > 애니메이션 몽타주** 를 선택하면 됩니다. 기존 애니메이션 시퀀스에 우클릭한 다음 맥락 메뉴에서 **몽타주 생성** 을 선택해도 됩니다. 그러면 선택된 애님 시퀀스가 디폴트 슬롯에 이미 설정된 상태로 새 몽타주가 자동 생성됩니다.

![](MakeMontage.png)

### 몽타주 셋업

첫 번째 할 일은 슬롯 이름을 지어주는 것이었습니다. 이 몽타주에서는 하나만 필요한데, 공격이 상체에만 영향을 끼치도록 하고프니 이름을 _Upper Body_ 로 해 주는 것이 완벽해 보였습니다. 그런 다음 이 슬롯에 필요할 애니메이션을 끌어 놓았습니다. 이 애니메이션이 하는 일은 다음과 같습니다:

* 우에서 좌로 해머 휘두르기
* 좌에서 우로 해머 휘두르기
* 우에서 좌 휘두르기가 끝에서 빈둥 상태로 복귀
* 좌에서 우 휘두르기가 끝나면 빈둥 상태로 복귀

[REGION:note]
두 가지 휘두르기 애니메이션 모두 다른 애니메이션의 시작 포즈에서 끝이 납니다. 즉 두 애니메이션을 루프로 재생하면 캐릭터가 해머를 앞뒤로 매끄럽게 휘두른다는 뜻입니다.
[/REGION]

순서가 엄청나게 중요하지는 않지만, 초반에 처음 두 애니메이션 이후 뒤로 돌아가는 것이 나중의 작업이 단순해 집니다.

![](MontageSetup.png)


### 섹션 생성

다음 단계는 몽타주 안에 애니메이션 섹션을 만들어, 필요할 때 블루프린트 코드에서 질의하여 호출할 수 있도록 하는 것입니다. 이 작업은 쉽게 몽타주 영역 상단의 섹션 트랙에 클릭중일 때 우클릭한 다음 **새 몽타주 섹션 추가** 를 선택하면 됩니다.

각 섹션마다 꽤 단순한 이름을 사용했습니다. 참고로 몽타주에 기본으로 딸려오는 디폴트 섹션을 (새로 만든 다음 디폴트에 우클릭한 후 **몽타주 섹션 삭제** 를 선택해서) 대체했습니다. 필요에 따라 섹션 트랙 위에서 섹션을 끌어 마우스를 놓으면 두 애니메이션 세그먼트 사이의 경계에 약간 달라붙는 것을 볼 수 있습니다. 이 기능을 활용해 보세요.

![](AddNewSections.png)



### 섹션 관계 정의


섹션이 생성되었으니, 섹션 영역을 사용해서 그 특수 관계를 정의할 수 있습니다. 예를 들어 _Swing1_ 과 _Swing2_ 섹션 사이의 관계를 정의하여 앞뒤로 루프 재생되도록 할 수 있습니다. 이 기능이 매우 유용합니다. 먼저 **비우기** 버튼을 클릭하여 기본 관계를 삭제합니다. 그런 다음 트랙을 선택해서 _Swing1_ 이 그 안에 들어가게 하고서, 섹션 영역 상단 근처의 **Swing2** 라벨이 붙은 녹색 버튼을 클릭하기만 하면 되는 일입니다. 그러면 _Swing2_ 트랙이 제거되고 _Swing1_ 트랙에 _Swing2_ 가 추가됩니다.

![](Swing2Track.png)

위 과정을 반복하여, 새로운 _Swing2_ 세그먼트를 클릭한 다음 _Swing1_ 버튼을 누르면, 시스템이 루프 생성을 감지하고 트랙이 파랗게 변합니다. 즉 Swing1 과 Swing2 세그먼트는 루핑 섹션으로 간주된다는 뜻입니다. 계속해서 앞뒤로 재생되어 무한 반복됩니다.

![](LoopingTracks.png)

### 브랜치 포인트 셋업

이제 약간의 브랜치 포인트를 설정하여 공격 애니메이션의 루프를 계속할지, 가능한 두가지 엔딩 중 하나로 점프할지를 테스트해 보겠습니다. 해줘야할 작업은 브랜치 포인트 트랙에 우클릭한 다음 **새 브랜치 포인트** 를 선택하는 것입니다. 이름은 _Swing_1_End_ 와 _Swing_2_End_ 로 지어 줬습니다. 마우스 휠로 매우 크게 줌 인 하여, 그 각각의 브랜치 포인트가 자신의 해당 섹션 가장 마지막 순간에 발동되도록 해 줬습니다. 즉 둘 사이 경계선에서 아주 약간 왼쪽으로 위치시켜 줬다는 뜻입니다.

![](BranchPointsSetUp.png)



[REGION:note]
브랜치 포인트 대신 노티파이를 사용하여 비슷한 구성을 할 수도 있지만, 타임라인상의 약간 이른 지점에 발동되도록 해 줘야 하며, 애니메이션 블루프린트 이벤트 그래프에서는 **Montage Jump to Section** 노드로 직접 전환해 주기 보다는 **Montage Set Next Section** 노드를 사용해서 적합한 엔딩 애니메이션 큐에 등록시켜줘야 합니다. 이러한 노티파이 작업은 퍼포먼스 비용이 약간 싸게 먹히는데, 노티파이는 비동기식이기 때문입니다. 저희 예제가 학습용이긴 하나, 다른 방법도 있음을 언급해 두고 싶었습니다.
[/REGION]


### 애님 그래프 셋업

이 시점에서 우리 몽타주 셋업은 끝났습니다. 이제 우리 몽타주의 결과를 읽어들일 수 있도록 애님 그래프 설정을 해 줄 필요가 있습니다. 이는 매우 단순한 프로세스이나, 진행 방식에 대해 진중히 고민하지 않아도 되게 해 줍니다. 우리 애님 그래프는 이와 같이 스테이트 머신의 결과만 보이는 곳을 살펴보는 것으로 시작합니다:

![](StateMachineResult.png)


몽타주의 재생이 Spine_01 본 (허리) 위로만 재생되도록 하고자 하니, **Layered Blend per Bone** 노드를 사용하겠습니다. 거기에 Blend Pose 를 추가하여 웨이트를 1 로 설정합니다. 노드의 프로퍼티에 이 Blend Pose 를 Spine_01 과 연결시켜 주기도 합니다. 그런 다음 **Slot** 노드를 들여온 다음 우리 슬롯 이름인 _UpperBody_ 로 설정합니다. 그런데 이제 문제가 생겼습니다:

![](SlotAndBlend.png)

Slot 노드는 몽타주 재생 완료시 예비로 쓸 Source 연결이 필요합니다. 그게 없을 경우 몽타주가 끝나면 캐릭터는 허리 위에서 부터 T 포즈로 돌아가 버립니다. 그러나 스테이트 머신을 **Layered Blend per Bone** 의 Base Pose 와 **Slot** 노드의 Source 에도 연결해 줄 수는 없는 노릇입니다. 해법은? **Cache** 노드를 사용합니다! 스테이트 머신의 결과를 Cache 노드에 저장한 다음, **Cached Pose** 노드를 사용하여 두 개의 인풋 모두에 연결해 주면 됩니다. 이는 스테이트 머신의 결과를 변수에 저장하여 여러 곳에 사용하는 것과 어느정도 비슷합니다. 이 예제의 경우 Cache 이름은 _LocoCache_ 로 합니다.

![](CachedLocomotion.png)

우리 애님 그래프가 완성되었습니다. UpperBody Slot 노드가 _아무_ 애님 몽타주에서 데이터를 받자 마자 (_UpperBody_ 라는 이름의 슬롯이 있기만 하면 어느 몽타주를 사용해도 됩니다), 블렌드 인 해 들어갑니다. 더이상 데이터를 받지 않게 되면, 스테이트 머신의 결과물로 돌아가게 됩니다.


### 이벤트 그래프 셋업

이벤트 그래프 셋업은 매우 기본적입니다. **Event Blueprint Update Animation** 노드를 사용하여 **Get Player Character** 노드의 출력 핀을 끌어놓으면, **캐릭터 블루프린트** (이 예제에서는 _MyCharacter_) 로 **Cast To** (형변환)시켜 그 블루프린트에서 변수와 함수 접근이 가능합니다. (블루프린트끼리의 통신 관련 상세 정보는 [](Engine\Blueprints\UserGuide\BlueprintComms) 문서를 참고하세요.)

_클릭하면 원래 크기로 봅니다._
[REGION:lightbox]
[![](PlayMontageEventGraph.png)(w:1020)](PlayMontageEventGraph.png)
[/REGION]

먼저 해 줄 것은 캐릭터 블루프린트의 **IsAttacking** 변수가 TRUE 인지 검사한 다음 그렇다면, 몽타주가 이미 재생중인지 검사합니다. 몽타주가 재생중이라면, 다시 재생하지 않습니다. 하지만 재생중이지 않다면, 몽타주를 재생합니다. 이런 식으로 재생 중간에 애니메이션이 재시작되어 안좋아 보이지 않도록 할 수 있습니다.

**Cast To** 노드에서 뻗어나오는 **IsAttacking** 노드에 이어서, 마우스 버튼이 계속 눌려 있는지 확인하고, 눌려있지 _않다면_ 루프의 어느 반쪽이 재생중이었는가에 따라 적합한 엔딩 애니메이션으로 점프합니다. 브랜치 포인트 이벤트의 생성은 우클릭한 다음 **Add Montage Branching Point Event** 아래 적합한 이벤트를 선택하면 됩니다.

![](EndLoopEventGraph.png)

다 됐습니다. 컴파일하면, 마우스 버튼이 눌려있는 한 계속해서 휘두르다가, 마우스 버튼을 놓는 시점에 따라 똑똑하게 애니메이션을 끝내는 캐릭터를 볼 수 있습니다!


[OBJECT:EmbeddedVideo]
[PARAMLITERAL:width]
640
[/PARAMLITERAL]
[PARAMLITERAL:height]
360
[/PARAMLITERAL]
[PARAMLITERAL:videoid]
6eMxjbkn6hs
[/PARAMLITERAL]
[/OBJECT]

-------------------->











