// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.IO;
using DoxygenLib;

namespace APIDocTool
{
	public abstract class APIMember : APIPage
	{
		private static Dictionary<string, APIMember> RefIdToMember = new Dictionary<string, APIMember>();

		public readonly List<APIMember> Children = new List<APIMember>();

		public APIMember(APIPage InParent, string InName)
			: base(InParent, InName)
		{
		}

		public APIMember(APIPage InParent, string InName, string InLinkPath)
			: base(InParent, InName, InLinkPath)
		{
		}

		public static List<APIMember> CreateChildren(APIPage Parent, IEnumerable<DoxygenEntity> Entities)
		{
			List<APIMember> Children = new List<APIMember>();
			Dictionary<APIFunctionKey, List<DoxygenEntity>> PendingFunctionGroups = new Dictionary<APIFunctionKey, List<DoxygenEntity>>();
			
			// List of autogenerated structs
			List<DoxygenEntity> GeneratedEntities = new List<DoxygenEntity>();

			// Parse the entities
			foreach (DoxygenEntity Entity in Entities)
			{
				if (Entity.Kind == "class" || Entity.Kind == "struct" || Entity.Kind == "union")
				{
					if (Entity.Kind == "struct" && Entity.Name.Contains("_event") && Entity.Name.EndsWith("_Parms"))
					{
						GeneratedEntities.Add(Entity);
					}
					else
					{
						APIRecord Record = new APIRecord(Parent, Entity);
						Record.Children.AddRange(CreateChildren(Record, Entity.Members));
						Children.Add(Record);
					}
				}
				else if (Entity.Kind == "function")
				{
					APIFunctionKey FunctionKey = APIFunctionKey.FromEntity(Parent, Entity);
					if (!Program.IgnoredFunctionMacros.Contains(FunctionKey.Name))
					{
						List<DoxygenEntity> EntityList;
						if (!PendingFunctionGroups.TryGetValue(FunctionKey, out EntityList))
						{
							EntityList = new List<DoxygenEntity>();
							PendingFunctionGroups.Add(FunctionKey, EntityList);
						}
						EntityList.Add(Entity);
					}
				}
				else if (Entity.Kind == "variable")
				{
					if (IsConstantVariable(Entity))
					{
						Children.Add(new APIConstantVariable(Parent, Entity));
					}
					else
					{
						Children.Add(new APIVariable(Parent, Entity.Node));
					}
				}
				else if (Entity.Kind == "typedef")
				{
					Children.Add(new APITypeDef(Parent, Entity));
				}
				else if (Entity.Kind == "enum")
				{
					if (Entity.Name != null && Entity.Name.StartsWith("@"))
					{
						// It's an enum constant
						Children.AddRange(APIConstantEnum.Read(Parent, Entity));
					}
					else
					{
						// It's an enum
						Children.Add(new APIEnum(Parent, Entity, Entity.Name));
					}
				}
			}

			// Fixup the functions
			foreach (KeyValuePair<APIFunctionKey, List<DoxygenEntity>> PendingFunctionGroup in PendingFunctionGroups)
			{
				if (PendingFunctionGroup.Value.Count == 1)
				{
					APIFunction Function = new APIFunction(Parent, PendingFunctionGroup.Value[0], PendingFunctionGroup.Key);
					Children.Add(Function);
				}
				else
				{
					APIFunctionGroup FunctionGroup = new APIFunctionGroup(Parent, PendingFunctionGroup.Key, PendingFunctionGroup.Value);
					Children.Add(FunctionGroup);
				}
			}

			// Attach all the autogenerated structures to their parent functions
			foreach(DoxygenEntity Entity in GeneratedEntities)
			{
				if(!CreateParametersStruct(Parent, Children, Entity))
				{
					APIRecord Record = new APIRecord(Parent, Entity);
					Record.Children.AddRange(CreateChildren(Record, Entity.Members));
					Children.Add(Record);
				}
			}

			// Sort the children by name
			Children.Sort((x, y) => String.Compare(x.Name, y.Name));
			return Children;
		}

		public static bool CreateParametersStruct(APIPage Parent, List<APIMember> Children, DoxygenEntity Entity)
		{
			string Name = Entity.Name;
			int ClassMaxIdx = Name.IndexOf("_event");
			if (ClassMaxIdx == -1) return false;

			string ClassName = Name.Substring(0, ClassMaxIdx);
			APIRecord ClassRecord = Children.OfType<APIRecord>().FirstOrDefault(x => x.Name.EndsWith(ClassName) && x.Name.Length == ClassName.Length + 1);
			if (ClassRecord == null) return false;

			if (!Name.EndsWith("_Parms")) return false;
			int MemberMinIdx = ClassMaxIdx + 6;
			int MemberMaxIdx = Name.Length - 6;
			string MemberName = Name.Substring(MemberMinIdx, MemberMaxIdx - MemberMinIdx);

			APIRecord Delegate = Children.OfType<APIRecord>().FirstOrDefault(x => x.Name == "F" + MemberName);
			if(Delegate != null)
			{
				Delegate.DelegateEventParameters = new APIEventParameters(Parent, Delegate, Entity);
				Children.Add(Delegate.DelegateEventParameters);
				return true;
			}

			APIFunction Function = ClassRecord.Children.OfType<APIFunction>().FirstOrDefault(x => x.Name == MemberName);
			if (Function != null)
			{
				Function.EventParameters = new APIEventParameters(Parent, Function, Entity);
				Children.Add(Function.EventParameters);
				return true;
			}

			return false;
		}

		public static bool IsConstantVariable(DoxygenEntity Entity)
		{
			return Entity.Node.Attributes["static"].Value == "yes";
		}

		public static void AddRefLink(string RefId, APIMember Member)
		{
			if (RefIdToMember.ContainsKey(RefId))
			{
				Console.WriteLine("Entity defined twice - {0} ({1})", Member.FullName, RefId);
			}
			else
			{
				RefIdToMember.Add(RefId, Member);
			}
		}

		public static APIMember ResolveRefLink(string RefId)
		{
			APIMember Member;
			if (RefIdToMember.TryGetValue(RefId, out Member))
			{
				return Member;
			}
			return null;
		}

		public static string ConvertToMarkdown(XmlNode Node, string Indent = "")
		{
			return Markdown.ParseXml(Node, Indent, ResolveDoxygenLink);
		}

		public static string RemoveElaborations(string Definition)
		{
			string Text = Definition;
			if (Text.StartsWith("class "))
			{
				Text = Text.Substring(6);
			}
			else if (Text.StartsWith("const class "))
			{
				Text = "const " + Text.Substring(12);
			}
			else if (Text.StartsWith("struct "))
			{
				Text = Text.Substring(7);
			}
			else if (Text.StartsWith("const struct "))
			{
				Text = "const " + Text.Substring(13);
			}
			return Text;
		}

		public static string ResolveDoxygenLink(string RefId)
		{
			APIMember Member = ResolveRefLink(RefId);
			return (Member == null) ? null : Member.LinkPath;
		}

		public string ShortName
		{
			get { int LastScopeIdx = Name.LastIndexOf("::"); return (LastScopeIdx == -1) ? Name : Name.Substring(LastScopeIdx + 2); }
		}

		public virtual string FullName
		{
			get { APIMember ParentMember = Parent as APIMember; return (ParentMember == null)? Name : (ParentMember.FullName + "::" + Name); }
		}

		public abstract void Link();

		public virtual void PostLink()
		{
		}

		public override void AddToManifest(UdnManifest Manifest)
		{
			// Check if this member has a name in the global scope
			if (FullName != null)
			{
				Manifest.Add(FullName, this);
			}

			// Add the children
			AddChildrenToManifest(Manifest);
		}

		public virtual void AddChildrenToManifest(UdnManifest Manifest)
		{
			foreach (APIMember Child in Children)
			{
				Child.AddToManifest(Manifest);
			}
		}

		public void WriteNestedSimpleCode(UdnWriter Writer, List<string> Lines)
		{
			Writer.EnterTag("[REGION:simplecode_api]");
			string Prefix = "";
	
			// Write the namespace introducers
			int LastScope = 0;
			for(int NextScope = Name.IndexOf("::"); NextScope != -1; NextScope = Name.IndexOf("::", NextScope + 2))
			{
				string Namespace = Name.Substring(LastScope, NextScope - LastScope);
				Writer.WriteLine(Prefix + "namespace " + Namespace + "  ");
				Writer.WriteLine(Prefix + Utility.EscapeText("{") + "  ");
				Prefix += UdnWriter.TabSpaces;
				LastScope = NextScope + 2;
			}

			// Write the body
			foreach (string Line in Lines)
			{
				Writer.WriteLine(Prefix + Line.Replace('\r', ' ').Replace('\n', ' ').Trim() + "  ");
			}

			// Write the closing braces
			while (Prefix.Length > 0)
			{
				Prefix = Prefix.Substring(0, Prefix.Length - UdnWriter.TabSpaces.Length);
				Writer.WriteLine(Prefix + Utility.EscapeText("}") + "  ");
			}

			Writer.LeaveTag("[/REGION]");
		}

		public void WriteReferencesSection(UdnWriter Writer, DoxygenEntity Entity)
		{
			List<UdnListItem> Items = new List<UdnListItem>();

			// Get the module
			for (APIPage Page = this; Page != null; Page = Page.Parent)
			{
				APIModule Module = Page as APIModule;
				if(Module != null)
				{
					Items.Add(new UdnListItem("Module", String.Format("[{0}]({1})", Module.Name, Module.LinkPath), null));
					break;
				}
			}

			// Get the header file
			if (Entity.File != null)
			{
				string NormalizedFileName = GetNormalizedFileName(Entity.File);
				if (NormalizedFileName != null)
				{
					Items.Add(new UdnListItem("Header", Utility.EscapeText(NormalizedFileName), null));
				}
			}

			// Get the source file
			if(Entity.BodyFile != null && Entity.BodyFile != Entity.File)
			{
				string NormalizedFileName = GetNormalizedFileName(Entity.BodyFile);
				if (NormalizedFileName != null)
				{
					Items.Add(new UdnListItem("Source", Utility.EscapeText(NormalizedFileName), null));
				}
			}

			// Write the section
			if(Items.Count > 0)
			{
				Writer.EnterSection("references", "References");
				Writer.WriteList(Items);
				Writer.LeaveSection();
			}
		}

		public void WriteSnippetSection(UdnWriter Writer, List<string> SnippetLines)
		{
			if (SnippetLines != null)
			{
				Writer.EnterSection("examplecode", "Example Code");
				foreach (string SnippetLine in SnippetLines)
				{
					Writer.WriteLine(SnippetLine + "  ");
				}
				Writer.LeaveSection();
			}
		}

		public static string GetNormalizedFileName(string InFileName)
		{
			string NormalizedFileName = InFileName.Replace('\\', '/');
			const string EngineSource = "/Engine/Source/";

			int SourceIndex = NormalizedFileName.IndexOf(EngineSource);
			if (SourceIndex != -1)
			{
				return NormalizedFileName.Substring(SourceIndex + EngineSource.Length);
			}

			return null;
		}

		public static string AnnotateAnonymousNames(string Name)
		{
			string[] Sections = Name.Split(new string[]{ "::" }, StringSplitOptions.None);
			for (int Idx = 0; Idx < Sections.Length; Idx++)
			{
				if (Sections[Idx].StartsWith("@")) Sections[Idx] = "<anonymous>";
			}
			return String.Join("::", Sections);
		}

		public static string ParseDescription(XmlNode Node, string Path)
		{
			XmlNode ChildNode = Node.SelectSingleNode(Path);
			if(ChildNode != null)
			{
				string Text = ConvertToMarkdown(ChildNode, "").Trim();
				if(Text.Length > 0 && Char.IsLower(Text[0]))
				{
					Text = Char.ToUpper(Text[0]) + Text.Substring(1);
				}
				return Text;
			}
			return "";
		}

		public static void ParseBriefAndFullDescription(XmlNode Node, out string BriefDescription, out string FullDescription)
		{
			BriefDescription = ParseDescription(Node, "briefdescription");
			FullDescription = ParseDescription(Node, "detaileddescription");

			if (Utility.IsNullOrWhitespace(BriefDescription))
			{
				BriefDescription = Utility.GetBriefDescription(FullDescription);
			}
			if (Utility.IsNullOrWhitespace(FullDescription))
			{
				FullDescription = BriefDescription;
			}
		}

		protected static void ParseSeeAlso(XmlNode Node, List<string> SeeAlso)
		{
			// Parse out all the @see nodes
			foreach (XmlNode SectionNode in Node.SelectNodes("detaileddescription/para/simplesect"))
			{
				XmlAttribute KindAttribute = SectionNode.Attributes["kind"];
				if (KindAttribute != null && KindAttribute.Value == "see")
				{
					foreach (XmlNode ChildNode in SectionNode.ChildNodes)
					{
						if (ChildNode.Name != "simplesectsep")
						{
							SeeAlso.Add(ConvertToMarkdown(ChildNode));
						}
					}
				}
			}

			// Split them all by commas
			for (int SeeAlsoIdx = 0; SeeAlsoIdx < SeeAlso.Count; SeeAlsoIdx++)
			{
				string Line = SeeAlso[SeeAlsoIdx];
				for (int Idx = 0; Idx < Line.Length; Idx = Markdown.SkipCharacter(Line, Idx))
				{
					if (Line[Idx] == ',')
					{
						SeeAlso[SeeAlsoIdx] = Line.Substring(0, Idx).TrimEnd();
						SeeAlso.Insert(SeeAlsoIdx + 1, Line.Substring(Idx + 1).TrimStart());
						break;
					}
				}
			}
		}

		protected static void WriteSeeAlsoSection(UdnWriter Writer, List<string> SeeAlso)
		{
			if (SeeAlso.Count > 0)
			{
				Writer.EnterSection("seealso", "See Also");
				foreach (string SeeAlsoLine in SeeAlso)
				{
					Writer.WriteLine(SeeAlsoLine);
					Writer.WriteLine();
				}
				Writer.LeaveSection();
			}
		}

		public static APIProtection ParseProtection(XmlNode Node)
		{
			XmlNode ProtNode = Node.Attributes.GetNamedItem("prot");
			if (ProtNode != null)
			{
				switch (ProtNode.InnerText)
				{
					case "public":
						return APIProtection.Public;
					case "protected":
						return APIProtection.Protected;
					case "private":
						return APIProtection.Private;
					default:
						throw new NotImplementedException();
				}
			}
			return APIProtection.Public;
		}

		public static string ParseTemplateSignature(XmlNode Node)
		{
			XmlNode TemplateParamList = Node.SelectSingleNode("templateparamlist");
			if (TemplateParamList != null)
			{
				string ParameterList = "";
				foreach (XmlNode TemplateParam in TemplateParamList.SelectNodes("param"))
				{
					if (ParameterList.Length > 0) ParameterList += ", ";
					ParameterList += ConvertToMarkdown(TemplateParam.SelectSingleNode("type"));

					XmlNode TemplateName = TemplateParam.SelectSingleNode("declname");
					if (TemplateName != null) ParameterList += " " + TemplateName.InnerText;
				}
				return "template&lt;" + ParameterList + "&gt;";
			}
			return null;
		}

		public override void GatherReferencedPages(List<APIPage> Pages)
		{
			Pages.AddRange(Children);
		}

		public override string ToString()
		{
			return LinkPath;
		}
	}
}
