// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

#include "NiagaraEditorPrivatePCH.h"
#include "BlueprintGraphDefinitions.h"
#include "GraphEditorSettings.h"

#include "NiagaraNodeOp.h"
#include "EdGraphSchema_Niagara.h"

#define LOCTEXT_NAMESPACE "NiagaraNodeOp"

UNiagaraNodeOp::UNiagaraNodeOp(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void UNiagaraNodeOp::AllocateDefaultPins()
{
	const UEdGraphSchema_Niagara* Schema = GetDefault<UEdGraphSchema_Niagara>();

	const FNiagaraOpInfo* OpInfo = FNiagaraOpInfo::GetOpInfo(OpName);
	check(OpInfo);

	for (int32 SrcIndex = 0; SrcIndex < OpInfo->Inputs.Num(); ++SrcIndex)
	{
		const FNiagaraOpInOutInfo& InOutInfo = OpInfo->Inputs[SrcIndex];
		if (InOutInfo.DataType == ENiagaraDataType::Scalar)
		{
			UEdGraphPin* Pin = CreatePin(EGPD_Input, Schema->PC_Float, TEXT(""), NULL, false, false, InOutInfo.FriendlyName.ToString());
			check(Pin);
			Pin->bDefaultValueIsIgnored = false;
			Pin->bDefaultValueIsReadOnly = false;
			Pin->bNotConnectable = false;
			Pin->DefaultValue = InOutInfo.Default;
			Pin->AutogeneratedDefaultValue = InOutInfo.Default;
			Pin->PinToolTip = InOutInfo.Description.ToString();
		}
		else if (InOutInfo.DataType == ENiagaraDataType::Vector)
		{
			UEdGraphPin* Pin = CreatePin(EGPD_Input, Schema->PC_Vector, TEXT(""), NULL, false, false, InOutInfo.FriendlyName.ToString());
			check(Pin);
			Pin->bDefaultValueIsIgnored = false;
			Pin->bDefaultValueIsReadOnly = false;
			Pin->bNotConnectable = false;
			Pin->DefaultValue = InOutInfo.Default;
			Pin->AutogeneratedDefaultValue = InOutInfo.Default;
			Pin->PinToolTip = InOutInfo.Description.ToString();
		}
		else if (InOutInfo.DataType == ENiagaraDataType::Matrix)
		{
			UEdGraphPin* Pin = CreatePin(EGPD_Input, Schema->PC_Matrix, TEXT(""), NULL, false, false, InOutInfo.FriendlyName.ToString());
			check(Pin);
			Pin->bDefaultValueIsIgnored = false;
			Pin->bDefaultValueIsReadOnly = false;
			Pin->bNotConnectable = false;
			Pin->DefaultValue = InOutInfo.Default;
			Pin->AutogeneratedDefaultValue = InOutInfo.Default;
			Pin->PinToolTip = InOutInfo.Description.ToString();
		}
	}
	
	for (int32 OutIdx = 0; OutIdx < OpInfo->Outputs.Num(); ++OutIdx)
	{
		const FNiagaraOpInOutInfo& InOutInfo = OpInfo->Outputs[OutIdx];
		if (InOutInfo.DataType == ENiagaraDataType::Scalar)
		{
			UEdGraphPin* Pin = CreatePin(EGPD_Output, Schema->PC_Float, TEXT(""), NULL, false, false, InOutInfo.FriendlyName.ToString());
			check(Pin);
			Pin->PinToolTip = InOutInfo.Description.ToString();
		}
		else if (InOutInfo.DataType == ENiagaraDataType::Vector)
		{
			UEdGraphPin* Pin = CreatePin(EGPD_Output, Schema->PC_Vector, TEXT(""), NULL, false, false, InOutInfo.FriendlyName.ToString());
			check(Pin);
			Pin->PinToolTip = InOutInfo.Description.ToString();
		}
		else if (InOutInfo.DataType == ENiagaraDataType::Matrix)
		{
			UEdGraphPin* Pin = CreatePin(EGPD_Output, Schema->PC_Matrix, TEXT(""), NULL, false, false, InOutInfo.FriendlyName.ToString());
			check(Pin);
			Pin->PinToolTip = InOutInfo.Description.ToString();
		}
	}
}

FText UNiagaraNodeOp::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	const FNiagaraOpInfo* OpInfo = FNiagaraOpInfo::GetOpInfo(OpName);
	check(OpInfo);
	return OpInfo->FriendlyName;
}

FText UNiagaraNodeOp::GetTooltipText()const
{
	const FNiagaraOpInfo* OpInfo = FNiagaraOpInfo::GetOpInfo(OpName);
	check(OpInfo);
	return OpInfo->Description;
}

FLinearColor UNiagaraNodeOp::GetNodeTitleColor() const
{
	return GetDefault<UGraphEditorSettings>()->FunctionCallNodeTitleColor;
}

void UNiagaraNodeOp::Compile(class INiagaraCompiler* Compiler, TArray<FNiagaraNodeResult>& Outputs)
{
	const FNiagaraOpInfo* OpInfo = FNiagaraOpInfo::GetOpInfo(OpName);
	check(OpInfo);
	int32 NumInputs = OpInfo->Inputs.Num();
	int32 NumOutputs = OpInfo->Outputs.Num();

	TArray<TNiagaraExprPtr> Inputs;
	bool bError = false;
	for (int32 i = 0; i < NumInputs; ++i)
	{
		UEdGraphPin *Pin = Pins[i];
		check(Pin->Direction == EGPD_Input);
		TNiagaraExprPtr InputExpr = Compiler->CompilePin(Pin);
		if (!InputExpr.IsValid())
		{
			bError = true;
			FFormatNamedArguments Args;
			Args.Add(TEXT("OpName"), GetNodeTitle(ENodeTitleType::FullTitle));
			FText Format = LOCTEXT("InputErrorFormat", "Error compiling input on {OpName} node.");
			Compiler->Error(FText::Format(Format, Args), this, Pin);
		}
		Inputs.Add(InputExpr);
	}
	
	TArray<TNiagaraExprPtr> OutputExpressions;
	if ( !bError && OpInfo->OpDelegate.Execute(Compiler, Inputs, OutputExpressions))
	{
		check(OutputExpressions.Num() == OpInfo->Outputs.Num());

		for (int32 i = 0; i < NumOutputs; ++i)
		{
			UEdGraphPin *Pin = Pins[NumInputs + i];
			check(Pin->Direction == EGPD_Output);
			Outputs.Add(FNiagaraNodeResult(OutputExpressions[i], Pin));
		}
	}
	else
	{
		FFormatNamedArguments Args;
		Args.Add(TEXT("OpName"), GetNodeTitle(ENodeTitleType::FullTitle));
		FText Format = LOCTEXT("NodeErrorFormat", "Error compiling {OpName} node.");
		Compiler->Error(FText::Format(Format, Args), this, nullptr);
	}
}

#undef LOCTEXT_NAMESPACE
