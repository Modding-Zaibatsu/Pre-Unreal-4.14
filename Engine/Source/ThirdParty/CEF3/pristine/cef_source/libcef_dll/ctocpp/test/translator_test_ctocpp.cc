// Copyright (c) 2016 The Chromium Embedded Framework Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the CEF translator tool. If making changes by
// hand only do so within the body of existing method and function
// implementations. See the translator.README.txt file in the tools directory
// for more information.
//

#include <algorithm>
#include "libcef_dll/cpptoc/test/translator_test_handler_cpptoc.h"
#include "libcef_dll/cpptoc/test/translator_test_handler_child_cpptoc.h"
#include "libcef_dll/ctocpp/test/translator_test_ctocpp.h"
#include "libcef_dll/ctocpp/test/translator_test_object_ctocpp.h"
#include "libcef_dll/ctocpp/test/translator_test_object_child_ctocpp.h"
#include "libcef_dll/transfer_util.h"


// STATIC METHODS - Body may be edited by hand.

CefRefPtr<CefTranslatorTest> CefTranslatorTest::Create() {
  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  cef_translator_test_t* _retval = cef_translator_test_create();

  // Return type: refptr_same
  return CefTranslatorTestCToCpp::Wrap(_retval);
}


// VIRTUAL METHODS - Body may be edited by hand.

void CefTranslatorTestCToCpp::GetVoid() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_void))
    return;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  _struct->get_void(_struct);
}

bool CefTranslatorTestCToCpp::GetBool() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_bool))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->get_bool(_struct);

  // Return type: bool
  return _retval?true:false;
}

int CefTranslatorTestCToCpp::GetInt() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_int))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->get_int(_struct);

  // Return type: simple
  return _retval;
}

double CefTranslatorTestCToCpp::GetDouble() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_double))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  double _retval = _struct->get_double(_struct);

  // Return type: simple
  return _retval;
}

long CefTranslatorTestCToCpp::GetLong() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_long))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  long _retval = _struct->get_long(_struct);

  // Return type: simple
  return _retval;
}

size_t CefTranslatorTestCToCpp::GetSizet() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_sizet))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  size_t _retval = _struct->get_sizet(_struct);

  // Return type: simple
  return _retval;
}

bool CefTranslatorTestCToCpp::SetVoid() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_void))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->set_void(_struct);

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::SetBool(bool val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_bool))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->set_bool(_struct,
      val);

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::SetInt(int val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_int))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->set_int(_struct,
      val);

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::SetDouble(double val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_double))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->set_double(_struct,
      val);

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::SetLong(long val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_long))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->set_long(_struct,
      val);

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::SetSizet(size_t val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_sizet))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->set_sizet(_struct,
      val);

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::SetIntList(const std::vector<int>& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_int_list))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: simple_vec_byref_const
  const size_t valCount = val.size();
  int* valList = NULL;
  if (valCount > 0) {
    valList = new int[valCount];
    DCHECK(valList);
    if (valList) {
      for (size_t i = 0; i < valCount; ++i) {
        valList[i] = val[i];
      }
    }
  }

  // Execute
  int _retval = _struct->set_int_list(_struct,
      valCount,
      valList);

  // Restore param:val; type: simple_vec_byref_const
  if (valList)
    delete [] valList;

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::GetIntListByRef(IntList& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_int_list_by_ref))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: simple_vec_byref
  size_t valSize = val.size();
  size_t valCount = std::max(GetIntListSize(), valSize);
  int* valList = NULL;
  if (valCount > 0) {
    valList = new int[valCount];
    DCHECK(valList);
    if (valList) {
       memset(valList, 0, sizeof(int)*valCount);
    }
    if (valList && valSize > 0) {
      for (size_t i = 0; i < valSize; ++i) {
        valList[i] = val[i];
      }
    }
  }

  // Execute
  int _retval = _struct->get_int_list_by_ref(_struct,
      &valCount,
      valList);

  // Restore param:val; type: simple_vec_byref
  val.clear();
  if (valCount > 0 && valList) {
    for (size_t i = 0; i < valCount; ++i) {
      val.push_back(valList[i]);
    }
    delete [] valList;
  }

  // Return type: bool
  return _retval?true:false;
}

size_t CefTranslatorTestCToCpp::GetIntListSize() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_int_list_size))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  size_t _retval = _struct->get_int_list_size(_struct);

  // Return type: simple
  return _retval;
}

CefString CefTranslatorTestCToCpp::GetString() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_string))
    return CefString();

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  cef_string_userfree_t _retval = _struct->get_string(_struct);

  // Return type: string
  CefString _retvalStr;
  _retvalStr.AttachToUserFree(_retval);
  return _retvalStr;
}

bool CefTranslatorTestCToCpp::SetString(const CefString& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_string))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val; type: string_byref_const
  DCHECK(!val.empty());
  if (val.empty())
    return false;

  // Execute
  int _retval = _struct->set_string(_struct,
      val.GetStruct());

  // Return type: bool
  return _retval?true:false;
}

void CefTranslatorTestCToCpp::GetStringByRef(CefString& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_string_by_ref))
    return;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  _struct->get_string_by_ref(_struct,
      val.GetWritableStruct());
}

bool CefTranslatorTestCToCpp::SetStringList(const std::vector<CefString>& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_string_list))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: string_vec_byref_const
  cef_string_list_t valList = cef_string_list_alloc();
  DCHECK(valList);
  if (valList)
    transfer_string_list_contents(val, valList);

  // Execute
  int _retval = _struct->set_string_list(_struct,
      valList);

  // Restore param:val; type: string_vec_byref_const
  if (valList)
    cef_string_list_free(valList);

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::GetStringListByRef(StringList& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_string_list_by_ref))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: string_vec_byref
  cef_string_list_t valList = cef_string_list_alloc();
  DCHECK(valList);
  if (valList)
    transfer_string_list_contents(val, valList);

  // Execute
  int _retval = _struct->get_string_list_by_ref(_struct,
      valList);

  // Restore param:val; type: string_vec_byref
  if (valList) {
    val.clear();
    transfer_string_list_contents(valList, val);
    cef_string_list_free(valList);
  }

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::SetStringMap(const StringMap& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_string_map))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: string_map_single_byref_const
  cef_string_map_t valMap = cef_string_map_alloc();
  DCHECK(valMap);
  if (valMap)
    transfer_string_map_contents(val, valMap);

  // Execute
  int _retval = _struct->set_string_map(_struct,
      valMap);

  // Restore param:val; type: string_map_single_byref_const
  if (valMap)
    cef_string_map_free(valMap);

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::GetStringMapByRef(std::map<CefString,
    CefString>& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_string_map_by_ref))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: string_map_single_byref
  cef_string_map_t valMap = cef_string_map_alloc();
  DCHECK(valMap);
  if (valMap)
    transfer_string_map_contents(val, valMap);

  // Execute
  int _retval = _struct->get_string_map_by_ref(_struct,
      valMap);

  // Restore param:val; type: string_map_single_byref
  if (valMap) {
    val.clear();
    transfer_string_map_contents(valMap, val);
    cef_string_map_free(valMap);
  }

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::SetStringMultimap(const std::multimap<CefString,
    CefString>& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_string_multimap))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: string_map_multi_byref_const
  cef_string_multimap_t valMultimap = cef_string_multimap_alloc();
  DCHECK(valMultimap);
  if (valMultimap)
    transfer_string_multimap_contents(val, valMultimap);

  // Execute
  int _retval = _struct->set_string_multimap(_struct,
      valMultimap);

  // Restore param:val; type: string_map_multi_byref_const
  if (valMultimap)
    cef_string_multimap_free(valMultimap);

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::GetStringMultimapByRef(StringMultimap& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_string_multimap_by_ref))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: string_map_multi_byref
  cef_string_multimap_t valMultimap = cef_string_multimap_alloc();
  DCHECK(valMultimap);
  if (valMultimap)
    transfer_string_multimap_contents(val, valMultimap);

  // Execute
  int _retval = _struct->get_string_multimap_by_ref(_struct,
      valMultimap);

  // Restore param:val; type: string_map_multi_byref
  if (valMultimap) {
    val.clear();
    transfer_string_multimap_contents(valMultimap, val);
    cef_string_multimap_free(valMultimap);
  }

  // Return type: bool
  return _retval?true:false;
}

CefPoint CefTranslatorTestCToCpp::GetPoint() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_point))
    return CefPoint();

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  cef_point_t _retval = _struct->get_point(_struct);

  // Return type: simple
  return _retval;
}

bool CefTranslatorTestCToCpp::SetPoint(const CefPoint& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_point))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  int _retval = _struct->set_point(_struct,
      &val);

  // Return type: bool
  return _retval?true:false;
}

void CefTranslatorTestCToCpp::GetPointByRef(CefPoint& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_point_by_ref))
    return;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  _struct->get_point_by_ref(_struct,
      &val);
}

bool CefTranslatorTestCToCpp::SetPointList(const std::vector<CefPoint>& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_point_list))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: simple_vec_byref_const
  const size_t valCount = val.size();
  cef_point_t* valList = NULL;
  if (valCount > 0) {
    valList = new cef_point_t[valCount];
    DCHECK(valList);
    if (valList) {
      for (size_t i = 0; i < valCount; ++i) {
        valList[i] = val[i];
      }
    }
  }

  // Execute
  int _retval = _struct->set_point_list(_struct,
      valCount,
      valList);

  // Restore param:val; type: simple_vec_byref_const
  if (valList)
    delete [] valList;

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::GetPointListByRef(PointList& val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_point_list_by_ref))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: simple_vec_byref
  size_t valSize = val.size();
  size_t valCount = std::max(GetPointListSize(), valSize);
  cef_point_t* valList = NULL;
  if (valCount > 0) {
    valList = new cef_point_t[valCount];
    DCHECK(valList);
    if (valList) {
       memset(valList, 0, sizeof(cef_point_t)*valCount);
    }
    if (valList && valSize > 0) {
      for (size_t i = 0; i < valSize; ++i) {
        valList[i] = val[i];
      }
    }
  }

  // Execute
  int _retval = _struct->get_point_list_by_ref(_struct,
      &valCount,
      valList);

  // Restore param:val; type: simple_vec_byref
  val.clear();
  if (valCount > 0 && valList) {
    for (size_t i = 0; i < valCount; ++i) {
      val.push_back(valList[i]);
    }
    delete [] valList;
  }

  // Return type: bool
  return _retval?true:false;
}

size_t CefTranslatorTestCToCpp::GetPointListSize() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_point_list_size))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  size_t _retval = _struct->get_point_list_size(_struct);

  // Return type: simple
  return _retval;
}

CefRefPtr<CefTranslatorTestObject> CefTranslatorTestCToCpp::GetObject(int val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_object))
    return NULL;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  cef_translator_test_object_t* _retval = _struct->get_object(_struct,
      val);

  // Return type: refptr_same
  return CefTranslatorTestObjectCToCpp::Wrap(_retval);
}

int CefTranslatorTestCToCpp::SetObject(CefRefPtr<CefTranslatorTestObject> val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_object))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val; type: refptr_same
  DCHECK(val.get());
  if (!val.get())
    return 0;

  // Execute
  int _retval = _struct->set_object(_struct,
      CefTranslatorTestObjectCToCpp::Unwrap(val));

  // Return type: simple
  return _retval;
}

CefRefPtr<CefTranslatorTestObject> CefTranslatorTestCToCpp::SetObjectAndReturn(
    CefRefPtr<CefTranslatorTestObject> val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_object_and_return))
    return NULL;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val; type: refptr_same
  DCHECK(val.get());
  if (!val.get())
    return NULL;

  // Execute
  cef_translator_test_object_t* _retval = _struct->set_object_and_return(
      _struct,
      CefTranslatorTestObjectCToCpp::Unwrap(val));

  // Return type: refptr_same
  return CefTranslatorTestObjectCToCpp::Wrap(_retval);
}

int CefTranslatorTestCToCpp::SetChildObject(
    CefRefPtr<CefTranslatorTestObjectChild> val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_child_object))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val; type: refptr_same
  DCHECK(val.get());
  if (!val.get())
    return 0;

  // Execute
  int _retval = _struct->set_child_object(_struct,
      CefTranslatorTestObjectChildCToCpp::Unwrap(val));

  // Return type: simple
  return _retval;
}

CefRefPtr<CefTranslatorTestObject> CefTranslatorTestCToCpp::SetChildObjectAndReturnParent(
    CefRefPtr<CefTranslatorTestObjectChild> val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_child_object_and_return_parent))
    return NULL;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val; type: refptr_same
  DCHECK(val.get());
  if (!val.get())
    return NULL;

  // Execute
  cef_translator_test_object_t* _retval =
      _struct->set_child_object_and_return_parent(_struct,
      CefTranslatorTestObjectChildCToCpp::Unwrap(val));

  // Return type: refptr_same
  return CefTranslatorTestObjectCToCpp::Wrap(_retval);
}

bool CefTranslatorTestCToCpp::SetObjectList(
    const std::vector<CefRefPtr<CefTranslatorTestObject>>& val, int val1,
    int val2) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_object_list))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: refptr_vec_same_byref_const
  const size_t valCount = val.size();
  cef_translator_test_object_t** valList = NULL;
  if (valCount > 0) {
    valList = new cef_translator_test_object_t*[valCount];
    DCHECK(valList);
    if (valList) {
      for (size_t i = 0; i < valCount; ++i) {
        valList[i] = CefTranslatorTestObjectCToCpp::Unwrap(val[i]);
      }
    }
  }

  // Execute
  int _retval = _struct->set_object_list(_struct,
      valCount,
      valList,
      val1,
      val2);

  // Restore param:val; type: refptr_vec_same_byref_const
  if (valList)
    delete [] valList;

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::GetObjectListByRef(ObjectList& val, int val1,
    int val2) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_object_list_by_ref))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: refptr_vec_same_byref
  size_t valSize = val.size();
  size_t valCount = std::max(GetObjectListSize(), valSize);
  cef_translator_test_object_t** valList = NULL;
  if (valCount > 0) {
    valList = new cef_translator_test_object_t*[valCount];
    DCHECK(valList);
    if (valList) {
       memset(valList, 0, sizeof(cef_translator_test_object_t*)*valCount);
    }
    if (valList && valSize > 0) {
      for (size_t i = 0; i < valSize; ++i) {
        valList[i] = CefTranslatorTestObjectCToCpp::Unwrap(val[i]);
      }
    }
  }

  // Execute
  int _retval = _struct->get_object_list_by_ref(_struct,
      &valCount,
      valList,
      val1,
      val2);

  // Restore param:val; type: refptr_vec_same_byref
  val.clear();
  if (valCount > 0 && valList) {
    for (size_t i = 0; i < valCount; ++i) {
      val.push_back(CefTranslatorTestObjectCToCpp::Wrap(valList[i]));
    }
    delete [] valList;
  }

  // Return type: bool
  return _retval?true:false;
}

size_t CefTranslatorTestCToCpp::GetObjectListSize() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_object_list_size))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  size_t _retval = _struct->get_object_list_size(_struct);

  // Return type: simple
  return _retval;
}

int CefTranslatorTestCToCpp::SetHandler(
    CefRefPtr<CefTranslatorTestHandler> val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_handler))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val; type: refptr_diff
  DCHECK(val.get());
  if (!val.get())
    return 0;

  // Execute
  int _retval = _struct->set_handler(_struct,
      CefTranslatorTestHandlerCppToC::Wrap(val));

  // Return type: simple
  return _retval;
}

CefRefPtr<CefTranslatorTestHandler> CefTranslatorTestCToCpp::SetHandlerAndReturn(
    CefRefPtr<CefTranslatorTestHandler> val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_handler_and_return))
    return NULL;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val; type: refptr_diff
  DCHECK(val.get());
  if (!val.get())
    return NULL;

  // Execute
  cef_translator_test_handler_t* _retval = _struct->set_handler_and_return(
      _struct,
      CefTranslatorTestHandlerCppToC::Wrap(val));

  // Return type: refptr_diff
  return CefTranslatorTestHandlerCppToC::Unwrap(_retval);
}

int CefTranslatorTestCToCpp::SetChildHandler(
    CefRefPtr<CefTranslatorTestHandlerChild> val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_child_handler))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val; type: refptr_diff
  DCHECK(val.get());
  if (!val.get())
    return 0;

  // Execute
  int _retval = _struct->set_child_handler(_struct,
      CefTranslatorTestHandlerChildCppToC::Wrap(val));

  // Return type: simple
  return _retval;
}

CefRefPtr<CefTranslatorTestHandler> CefTranslatorTestCToCpp::SetChildHandlerAndReturnParent(
    CefRefPtr<CefTranslatorTestHandlerChild> val) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_child_handler_and_return_parent))
    return NULL;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val; type: refptr_diff
  DCHECK(val.get());
  if (!val.get())
    return NULL;

  // Execute
  cef_translator_test_handler_t* _retval =
      _struct->set_child_handler_and_return_parent(_struct,
      CefTranslatorTestHandlerChildCppToC::Wrap(val));

  // Return type: refptr_diff
  return CefTranslatorTestHandlerCppToC::Unwrap(_retval);
}

bool CefTranslatorTestCToCpp::SetHandlerList(
    const std::vector<CefRefPtr<CefTranslatorTestHandler>>& val, int val1,
    int val2) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, set_handler_list))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Translate param: val; type: refptr_vec_diff_byref_const
  const size_t valCount = val.size();
  cef_translator_test_handler_t** valList = NULL;
  if (valCount > 0) {
    valList = new cef_translator_test_handler_t*[valCount];
    DCHECK(valList);
    if (valList) {
      for (size_t i = 0; i < valCount; ++i) {
        valList[i] = CefTranslatorTestHandlerCppToC::Wrap(val[i]);
      }
    }
  }

  // Execute
  int _retval = _struct->set_handler_list(_struct,
      valCount,
      valList,
      val1,
      val2);

  // Restore param:val; type: refptr_vec_diff_byref_const
  if (valList)
    delete [] valList;

  // Return type: bool
  return _retval?true:false;
}

bool CefTranslatorTestCToCpp::GetHandlerListByRef(HandlerList& val,
    CefRefPtr<CefTranslatorTestHandler> val1,
    CefRefPtr<CefTranslatorTestHandler> val2) {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_handler_list_by_ref))
    return false;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Verify param: val1; type: refptr_diff
  DCHECK(val1.get());
  if (!val1.get())
    return false;
  // Verify param: val2; type: refptr_diff
  DCHECK(val2.get());
  if (!val2.get())
    return false;

  // Translate param: val; type: refptr_vec_diff_byref
  size_t valSize = val.size();
  size_t valCount = std::max(GetObjectListSize(), valSize);
  cef_translator_test_handler_t** valList = NULL;
  if (valCount > 0) {
    valList = new cef_translator_test_handler_t*[valCount];
    DCHECK(valList);
    if (valList) {
       memset(valList, 0, sizeof(cef_translator_test_handler_t*)*valCount);
    }
    if (valList && valSize > 0) {
      for (size_t i = 0; i < valSize; ++i) {
        valList[i] = CefTranslatorTestHandlerCppToC::Wrap(val[i]);
      }
    }
  }

  // Execute
  int _retval = _struct->get_handler_list_by_ref(_struct,
      &valCount,
      valList,
      CefTranslatorTestHandlerCppToC::Wrap(val1),
      CefTranslatorTestHandlerCppToC::Wrap(val2));

  // Restore param:val; type: refptr_vec_diff_byref
  val.clear();
  if (valCount > 0 && valList) {
    for (size_t i = 0; i < valCount; ++i) {
      val.push_back(CefTranslatorTestHandlerCppToC::Unwrap(valList[i]));
    }
    delete [] valList;
  }

  // Return type: bool
  return _retval?true:false;
}

size_t CefTranslatorTestCToCpp::GetHandlerListSize() {
  cef_translator_test_t* _struct = GetStruct();
  if (CEF_MEMBER_MISSING(_struct, get_handler_list_size))
    return 0;

  // AUTO-GENERATED CONTENT - DELETE THIS COMMENT BEFORE MODIFYING

  // Execute
  size_t _retval = _struct->get_handler_list_size(_struct);

  // Return type: simple
  return _retval;
}


// CONSTRUCTOR - Do not edit by hand.

CefTranslatorTestCToCpp::CefTranslatorTestCToCpp() {
}

template<> cef_translator_test_t* CefCToCpp<CefTranslatorTestCToCpp,
    CefTranslatorTest, cef_translator_test_t>::UnwrapDerived(
    CefWrapperType type, CefTranslatorTest* c) {
  NOTREACHED() << "Unexpected class type: " << type;
  return NULL;
}

#ifndef NDEBUG
template<> base::AtomicRefCount CefCToCpp<CefTranslatorTestCToCpp,
    CefTranslatorTest, cef_translator_test_t>::DebugObjCt = 0;
#endif

template<> CefWrapperType CefCToCpp<CefTranslatorTestCToCpp, CefTranslatorTest,
    cef_translator_test_t>::kWrapperType = WT_TRANSLATOR_TEST;
